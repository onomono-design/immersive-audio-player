<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Immersive Audio Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js"></script>
    <!-- External CSS -->
    <link rel="stylesheet" href="player-layout.css">
    <link rel="stylesheet" href="player-controls.css">
    <!-- Inline CSS for components not in external files -->
    <style>
      /* Global styles to prevent scrolling */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: fixed;
        touch-action: none;
        -webkit-overflow-scrolling: none;
      }
      
      /* Base container styles */
      .immersive-track-container {
        font-family: sans-serif;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: linear-gradient(135deg, #2c3e50, #4ca1af);
        touch-action: none;
      }

      /* XR scene specific styles - Critical z-index adjustments */
      .xr-scene {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9000 !important; /* Super high z-index to ensure visibility */
        pointer-events: auto;
        background-color: transparent !important;
        display: block !important;
        opacity: 1 !important;
      }
      
      /* When body has this class, ensure all A-Frame elements are completely hidden */
      body.xr-scene-hidden .xr-scene,
      body.xr-scene-hidden a-scene,
      body.xr-scene-hidden .a-canvas {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
      }
      
      /* When body does NOT have this class, ensure XR elements can be visible */
      body:not(.xr-scene-hidden) .xr-scene {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      body:not(.xr-scene-hidden) a-scene,
      body:not(.xr-scene-hidden) .a-canvas {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      /* Hide A-Frame attribution and VR button */
      .a-enter-ar, .a-enter-vr, .a-orientation-modal, .a-dialog-allow-button {
        display: none !important;
      }
      
      /* Ensure A-Frame canvas is visible and properly positioned */
      .a-canvas {
        position: absolute !important;
        left: 0 !important;
        top: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important; 
        height: 100% !important;
        z-index: 9001 !important; /* Canvas needs highest z-index */
        display: block !important;
        background-color: transparent !important;
        opacity: 1 !important;
        visibility: visible !important;
      }
      
      /* Centered album art */
      .centered-album-art {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: calc(100% - 40px); /* Fill available width with padding */
        max-width: 100vh; /* Prevent extremely wide displays from stretching too much */
        /* Height calculation ensures no overlap with controls */
        height: min(calc(100vh - 200px), calc(100vw - 40px));
        max-height: calc(100vh - 200px); /* Ensure it doesn't overlap with controls */
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 2;
      }
      
      .centered-album-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      /* Loading overlay */
      .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        z-index: 10000; /* Super high z-index */
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .loading-overlay.active {
        opacity: 1;
        pointer-events: all;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      /* Player controls need to be above everything except the XR scene */
      .audio-controls {
        position: absolute;
        z-index: 9500 !important;
      }
      
      /* XR buttons need to be above everything except loading overlay */
      .xr-buttons {
        position: absolute;
        z-index: 9900 !important;
      }
      
      /* Debug info */
      .debug-info { display: none !important;
        position: fixed;
        bottom: 15px;
        left: 15px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 10500;
        max-width: 300px;
        word-break: break-all;
      }
      
      /* Responsive adjustments */
      @media (max-width: 480px) {
        .centered-album-art {
          width: calc(100% - 30px);
          height: min(calc(100vh - 180px), calc(100vw - 30px));
        }
      }
      
      /* Landscape mode for mobile devices */
      @media (max-height: 500px) and (orientation: landscape) {
        .centered-album-art {
          width: 70%;
          height: calc(100vh - 150px);
          max-height: 60vh;
          top: calc(50% - 20px);
        }
      }
      
      /* Playlist Button in Controls */
      .playlist-btn {
        margin-right: 8px;
      }
      
      .playlist-btn svg {
        width: 24px;
        height: 24px;
      }
      
      /* Playlist Overlay Styles */
      .playlist-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 9600;
        display: none;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .playlist-overlay.active {
        display: flex;
        opacity: 1;
      }
      
      .playlist-container {
        background-color: #2c3e50;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        border-radius: 12px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }
      
      .playlist-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        background-color: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      .playlist-header h3 {
        color: white;
        margin: 0;
        font-size: 18px;
      }
      
      .close-playlist-btn {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }
      
      .close-playlist-btn:hover {
        opacity: 1;
      }
      
      .playlist-tracks {
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
        max-height: calc(80vh - 60px);
      }
      
      .playlist-tracks li {
        padding: 12px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        transition: background-color 0.2s ease;
      }
      
      .playlist-tracks li:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }
      
      .playlist-tracks li.active {
        background-color: rgba(76, 161, 175, 0.3);
      }
      
      .track-title {
        font-weight: bold;
        margin-bottom: 4px;
      }
      
      .track-chapter {
        font-size: 0.8em;
        opacity: 0.7;
      }
      
      /* Responsive adjustments for playlist */
      @media (max-width: 480px) {
        .playlist-container {
          width: 95%;
          max-height: 90vh;
        }
      }
      
      @media (max-height: 500px) and (orientation: landscape) {
        .playlist-container {
          max-height: 80vh;
        }
      }
      
      /* Prevent text selection during scrubbing */
      body.scrubbing-in-progress {
        user-select: none;
        -webkit-user-select: none;
        cursor: grabbing;
      }
      
      /* Improve visual feedback when scrubbing */
      .progress-bar.scrubbing .progress-filled {
        background-color: #1ED760; /* Brighter green when active */
        transition: none; /* Remove transition for immediate feedback */
      }
      
      /* Make progress bar more responsive to hover */
      .progress-bar:hover {
        background-color: rgba(255, 255, 255, 0.3);
      }
      
      /* Add a subtle transition for hover effects */
      .progress-bar, .progress-filled, .progress-filled::after {
        transition: all 0.15s ease;
      }
      
      /* Recenter camera button styles */
      #recenter-camera-btn {
        transition: background-color 0.3s ease, transform 0.2s ease;
      }
      
      #recenter-camera-btn:active {
        transform: scale(0.95);
      }
      
      #recenter-camera-btn.active {
        background-color: #1DB954 !important;
      }

      /* XR button styles */
      #launch-xr {
        position: relative;
        transition: all 0.3s ease;
      }

      #launch-xr:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background-color: #888;
      }
      
      #launch-xr:disabled::after {
        content: '';
        display: inline-block;
        width: 10px;
        height: 10px;
        margin-left: 8px;
        border: 2px solid rgba(255,255,255,0.7);
        border-top-color: transparent;
        border-radius: 50%;
        animation: xr-button-loading 1s linear infinite;
        vertical-align: middle;
      }
      
      @keyframes xr-button-loading {
        to { transform: rotate(360deg); }
      }
      
      /* Permission overlay styles */
      .permission-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 10001;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      
      .permission-overlay.active {
        opacity: 1;
        pointer-events: auto;
      }
      
      .permission-container {
        background-color: #1a1a1a;
        border-radius: 12px;
        padding: 30px;
        max-width: 90%;
        width: 400px;
        text-align: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }
      
      .permission-icon {
        margin: 0 auto 20px;
        width: 80px;
        height: 80px;
        background-color: #4ca1af;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      
      .permission-title {
        color: white;
        font-size: 20px;
        margin: 0 0 15px;
      }
      
      .permission-message {
        color: rgba(255, 255, 255, 0.8);
        font-size: 16px;
        line-height: 1.5;
        margin-bottom: 25px;
      }
      
      .permission-button {
        background-color: #4ca1af;
        color: white;
        border: none;
        border-radius: 25px;
        padding: 12px 25px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      
      .permission-button:hover {
        background-color: #3d8a97;
      }
      
      .permission-button:active {
        transform: scale(0.98);
      }
      
      .loading-status {
        margin-bottom: 25px;
        text-align: center;
      }
      
      .permission-spinner {
        width: 40px;
        height: 40px;
        margin: 0 auto 15px;
        border-width: 3px;
      }
      
      .loading-progress {
        color: rgba(255, 255, 255, 0.8);
        font-size: 16px;
        line-height: 1.4;
      }
      
      #loading-progress-text {
        font-weight: bold;
        color: #4ca1af;
      }
    </style>
  </head>
  <body>
    <div class="immersive-track-container" id="player-container">
      <!-- Centered Album Art -->
      <div class="centered-album-art">
        <img id="album-art" alt="Album Art">
      </div>

      <!-- XR Scene Container - This needs to be above all other elements -->
      <div id="xr-scene-container" class="xr-scene">
        <a-scene
          xr-mode-ui="enabled: false"
          vr-mode-ui="enabled: false"
          renderer="antialias: true; colorManagement: true; precision: high; logarithmicDepthBuffer: true;"
          embedded
          loading-screen="enabled: false"
          device-orientation-permission-ui="enabled: false"
          inspector="url: https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js"
        >
          <a-assets timeout="30000">
            <video id="xr-video" preload="auto" crossorigin="anonymous" playsinline webkit-playsinline loop muted></video>
          </a-assets>
          <a-videosphere src="#xr-video" rotation="0 -90 0" radius="100" segments-height="64" segments-width="64"></a-videosphere>
          <a-entity camera position="0 1.6 0" look-controls="enabled: true; reverseMouseDrag: false; touchEnabled: true; magicWindowTrackingEnabled: true" wasd-controls="enabled: false"></a-entity>
        </a-scene>
      </div>

      <!-- Player Controls Section -->
      <div class="audio-controls">
        <div class="track-info">
          <h4 id="track-name"></h4>
          <p id="chapter-name"></p>
          <div class="player-progress">
            <div class="progress-bar">
              <div class="progress-filled"></div>
            </div>
            <div class="time-display">
              <span id="current-time">0:00</span>
              <span id="duration">0:00</span>
            </div>
          </div>
          <div class="playback-controls">
            <button id="playlist-btn" class="control-btn playlist-btn" title="Show playlist">
              <svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/>
              </svg>
            </button>
            <button id="rewind-btn" class="control-btn rewind-btn" title="Rewind 10 seconds">
              <span class="time-shift-value">-10s</span>
              <svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M12.5,3C17.15,3 21.08,6.03 22.47,10.22L20.1,11C19.05,7.81 16.04,5.5 12.5,5.5C10.54,5.5 8.77,6.22 7.38,7.38L10,10H3V3L5.6,5.6C7.45,4 9.85,3 12.5,3M10,12V22H8V14H6V12H10M18,14V20C18,21.11 17.11,22 16,22H14A2,2 0 0,1 12,20V14A2,2 0 0,1 14,12H16C17.11,12 18,12.9 18,14M14,14V20H16V14H14Z"/>
              </svg>
            </button>
            <button id="play-pause-btn" class="control-btn play-pause-btn">
              <svg class="play-icon" viewBox="0 0 24 24">
                <path fill="currentColor" d="M8 5v14l11-7z"/>
              </svg>
              <svg class="pause-icon" viewBox="0 0 24 24" style="display: none;">
                <path fill="currentColor" d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
              </svg>
            </button>
            <button id="forward-btn" class="control-btn forward-btn" title="Forward 10 seconds">
              <span class="time-shift-value">+10s</span>
              <svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M10,12V22H8V14H6V12H10M18,14V20C18,21.11 17.11,22 16,22H14A2,2 0 0,1 12,20V14A2,2 0 0,1 14,12H16C17.11,12 18,12.9 18,14M14,14V20H16V14H14M11.5,3C14.15,3 16.55,4 18.4,5.6L21,3V10H14L16.62,7.38C15.23,6.22 13.46,5.5 11.5,5.5C7.96,5.5 4.95,7.81 3.9,11L1.53,10.22C2.92,6.03 6.85,3 11.5,3Z"/>
              </svg>
            </button>
            <button id="mute-btn" class="control-btn mute-btn" title="Toggle mute">
              <svg class="volume-icon" viewBox="0 0 24 24">
                <path fill="currentColor" d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"/>
              </svg>
              <svg class="mute-icon" viewBox="0 0 24 24" style="display: none;">
                <path fill="currentColor" d="M12,4L9.91,6.09L12,8.18V4M4.27,3L3,4.27L7.73,9H3V15H7L12,20V13.27L16.25,17.53C15.58,18.04 14.83,18.46 14,18.7V20.77C15.38,20.45 16.63,19.82 17.68,18.96L19.73,21L21,19.73L12,10.73L4.27,3M19,12C19,12.94 18.8,13.82 18.46,14.64L19.97,16.15C20.62,14.91 21,13.5 21,12C21,7.72 18,4.14 14,3.23V5.29C16.89,6.15 19,8.83 19,12M16.5,12C16.5,10.23 15.5,8.71 14,7.97V10.18L16.45,12.63C16.5,12.43 16.5,12.21 16.5,12Z"/>
              </svg>
            </button>
            <audio id="audio" preload="metadata">
              <source id="audio-src" type="audio/mpeg">
              Your browser does not support the audio element.
            </audio>
          </div>
        </div>
      </div>

      <!-- Playlist Overlay -->
      <div id="playlist-overlay" class="playlist-overlay">
        <div class="playlist-container">
          <div class="playlist-header">
            <h3>Playlist</h3>
            <button id="close-playlist-btn" class="close-playlist-btn">×</button>
          </div>
          <ul id="playlist-tracks" class="playlist-tracks">
            <!-- Playlist items will be dynamically inserted here -->
          </ul>
        </div>
      </div>

      <div class="xr-buttons" id="xr-controls">
        <button id="launch-xr" disabled>Loading XR Content...</button>
        <button id="exit-xr" style="display: none;">Exit XR</button>
        <button id="recenter-camera-btn" style="display: none;">Recenter Camera</button>
      </div>

      <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div>Loading immersive experience...</div>
      </div>
      
      <!-- Custom device orientation permission overlay -->
      <div class="permission-overlay" id="permission-overlay" style="display: none">
        <div class="permission-container">
          <div class="permission-icon">
            <svg viewBox="0 0 24 24" width="64" height="64">
              <path fill="white" d="M12,18.5C12,19.33 11.33,20 10.5,20H4C2.89,20 2,19.1 2,18V6C2,4.89 2.89,4 4,4H10.5C11.33,4 12,4.67 12,5.5V18.5M12,5.5V18.5H18.5C19.33,18.5 20,17.83 20,17V7C20,6.17 19.33,5.5 18.5,5.5H12M21.08,12.42L20.12,11.46L20.82,10.76C20.92,10.66 20.9,10.5 20.78,10.42L19.6,9.57C19.5,9.47 19.33,9.5 19.24,9.6L18.54,10.3L17.58,9.34L18.28,8.64C18.38,8.54 18.36,8.38 18.24,8.3L17.06,7.45C16.95,7.35 16.78,7.38 16.7,7.5L16,8.2L15.04,7.24L15.74,6.54C15.84,6.44 15.82,6.27 15.7,6.18L14.5,5.36C14.4,5.26 14.23,5.28 14.14,5.4L13.44,6.08L12.5,5.12L13.2,4.41C13.3,4.31 13.28,4.14 13.15,4.06L11.96,3.21C11.83,3.13 11.67,3.16 11.56,3.27L10.86,4L11.08,4.17C10.87,4.28 10.63,4.45 10.41,4.67C8.84,6.3 8.85,8.73 10.43,10.24C12.05,11.79 14.53,11.8 16.11,10.17C17.68,8.53 17.68,6.09 16.1,4.58C15.93,4.42 15.77,4.28 15.59,4.17L15.84,4L16.5,3.3C16.61,3.19 16.59,3.03 16.47,2.95L15.28,2.1C15.15,2.01 14.98,2.04 14.89,2.15L14.15,2.84L13.2,1.92L13.89,1.21C13.99,1.11 13.98,0.95 13.86,0.87L12.66,0.05C12.54,-0.05 12.37,-0.03 12.28,0.09L11.55,0.82L10.6,0L9.78,0.76L10.73,1.74L10,2.45C9.9,2.55 9.88,2.72 10,2.82L11.2,3.69C11.33,3.77 11.5,3.75 11.57,3.64L12.31,2.9L13.27,3.86L12.53,4.6C12.43,4.7 12.45,4.87 12.57,4.95L13.77,5.82C13.9,5.92 14.06,5.89 14.13,5.78L14.87,5L15.83,5.96L15.09,6.69C15,6.79 15,6.95 15.13,7.05L16.33,7.9C16.46,8 16.62,7.97 16.7,7.86L17.44,7.12L18.43,8.11L17.7,8.8C17.6,8.91 17.61,9.07 17.74,9.16L18.94,10.04C19.08,10.12 19.24,10.09 19.33,9.98L20.06,9.25L21.05,10.24L20.32,10.93C20.22,11.03 20.23,11.2 20.35,11.28L21.53,12.13C21.66,12.21 21.82,12.19 21.91,12.08L22.64,11.34L22.43,11.14C22.55,11 22.66,10.82 22.75,10.61C22.83,10.42 22.88,10.22 22.91,10.03L22.08,10.86L21.08,12.42Z" />
            </svg>
          </div>
          <h2 class="permission-title" id="permission-title">Motion Sensors Access Required</h2>
          <p class="permission-message" id="permission-message">
            To experience 360° content, we need permission to use your device's motion sensors.
            This allows you to look around the immersive environment by moving your device.
          </p>
          <div class="loading-status" id="permission-loading-status" style="display: none;">
            <div class="loading-spinner permission-spinner"></div>
            <div class="loading-progress">Preparing immersive experience... <span id="loading-progress-text">0%</span></div>
          </div>
          <button id="request-permission-btn" class="permission-button">Enable 360° Experience</button>
        </div>
      </div>
      
      <!-- Debug info panel -->
      <div class="debug-info" id="debug-info" style="display:none;"></div>

      <!-- External JS - Import in this order -->
      <script src="shared-state.js"></script>
      <script src="media-preloader.js"></script>
      <script src="playlist-manager.js"></script>
      <script src="player-core.js"></script>
      <script src="player-controls.js"></script>
      <script src="xr-mode.js"></script>

      <!-- Initialize Player -->
      <script>
        document.addEventListener('DOMContentLoaded', () => {
          // Set the initial state to hide XR scene
          document.body.classList.add('xr-scene-hidden');
          
          // Disable all scrolling
          document.body.addEventListener('touchmove', function(e) {
            e.preventDefault();
          }, { passive: false });
          
          document.body.addEventListener('wheel', function(e) {
            e.preventDefault();
          }, { passive: false });
          
          // Enable debug mode for troubleshooting
          const DEBUG = false;
          const debugInfo = document.getElementById('debug-info');
          
          // Helper function to log debug info
          function logDebug(message) {
            if (!DEBUG) return;
            console.log(message);
            if (debugInfo) {
              debugInfo.style.display = 'block';
              debugInfo.innerHTML += message + '<br>';
              // Keep only last 10 messages instead of 5 for more context
              const lines = debugInfo.innerHTML.split('<br>');
              if (lines.length > 11) {
                debugInfo.innerHTML = lines.slice(lines.length - 11).join('<br>');
              }
            }
          }
          
          // Device detection
          const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
          
          logDebug(`Device detection: Mobile=${isMobile}, iOS=${isIOS}`);
          
          // Handle device orientation permission request
          setupDeviceOrientationPermissions();
          
          function setupDeviceOrientationPermissions() {
            const permissionOverlay = document.getElementById('permission-overlay');
            const requestPermissionBtn = document.getElementById('request-permission-btn');
            const permissionTitle = document.getElementById('permission-title');
            const permissionMessage = document.getElementById('permission-message');
            const permissionLoadingStatus = document.getElementById('permission-loading-status');
            const loadingProgressText = document.getElementById('loading-progress-text');
            const launchXrBtn = document.getElementById('launch-xr');
            
            // Required preload checks
            let videoPreloaded = false;
            let videoHasBuffer = false;
            let audioPreloaded = false;
            let permissionGranted = false;
            let xrModeReady = false;
            
            if (!permissionOverlay || !requestPermissionBtn) {
              logDebug('Permission overlay elements not found');
              return;
            }
            
            // Check if we're on iOS with permission API
            const needsIOSPermission = (isIOS && 
                typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function');
            
            // For iOS devices that need permission
            if (needsIOSPermission) {
              logDebug('iOS device orientation permission API detected');
              permissionTitle.textContent = 'Motion Sensors Access Required';
              permissionMessage.textContent = 'To experience 360° content, we need permission to use your device\'s motion sensors. This allows you to look around the immersive environment by moving your device.';
            } else if (isMobile) {
              // For other mobile devices
              logDebug('Mobile device detected, preparing experience');
              permissionTitle.textContent = 'Prepare Immersive Experience';
              permissionMessage.textContent = 'Tap the button below to load the 360° experience. This will prepare all resources needed for smooth playback.';
            } else {
              // For desktop
              logDebug('Desktop device detected, preparing experience');
              permissionTitle.textContent = 'Enter 360° Mode';
              permissionMessage.textContent = 'Click the button below to load the 360° experience. This gives you an immersive view that you can explore by dragging with your mouse.';
            }
            
            // Modify launch XR button to always show permission/loading overlay first
            if (launchXrBtn) {
              launchXrBtn.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Show the permission overlay with appropriate messaging
                permissionOverlay.style.display = 'flex';
                setTimeout(() => {
                  permissionOverlay.classList.add('active');
                }, 10);
                
                // Start preloading in the background
                startPreloading();
                
                return false;
              };
            }
            
            // Set up permission request button
            requestPermissionBtn.addEventListener('click', function() {
              logDebug('Permission request button clicked');
              
              // Different flows based on device type
              if (needsIOSPermission) {
                // iOS specific flow - request device orientation permission
                DeviceOrientationEvent.requestPermission()
                  .then(response => {
                    if (response === 'granted') {
                      logDebug('Device orientation permission granted');
                      permissionGranted = true;
                      
                      // Switch to loading UI
                      showLoadingUI();
                      
                      // Start preloading content
                      startPreloading();
                    } else {
                      logDebug(`Permission response: ${response}`);
                      alert('360° viewing requires motion sensor permission. Please try again.');
                    }
                  })
                  .catch(error => {
                    logDebug(`Permission error: ${error}`);
                    alert('Could not access motion sensors. Please try again.');
                  });
              } else {
                // Non-iOS flow - just start preloading
                permissionGranted = true; // No permission needed for non-iOS
                
                // Switch to loading UI
                showLoadingUI();
                
                // Start preloading content
                startPreloading();
              }
            });
            
            // Function to show loading UI
            function showLoadingUI() {
              requestPermissionBtn.style.display = 'none';
              permissionLoadingStatus.style.display = 'block';
              
              if (needsIOSPermission) {
                permissionTitle.textContent = 'Preparing 360° Experience';
                permissionMessage.textContent = 'Please wait while we load all resources for a smooth experience...';
              } else if (isMobile) {
                permissionTitle.textContent = 'Loading Immersive Experience';
                permissionMessage.textContent = 'Please wait while we prepare everything for a smooth 360° experience...';
              } else {
                permissionTitle.textContent = 'Preparing 360° Mode';
                permissionMessage.textContent = 'Please wait while we set up your immersive experience...';
              }
            }
            
            // Function to start preloading content
            function startPreloading() {
              // Ensure video is preloaded
              const video = document.getElementById('xr-video');
              const audio = document.getElementById('audio');
              
              // Update loading progress
              updateLoadingProgress(5);
              
              // Make sure we don't enter XR mode until everything is ready
              if (video && !videoPreloaded) {
                logDebug('Starting video preload');
                
                // If video already has a source, use it
                if (!video.src && initialTrack && initialTrack.videoSrc) {
                  video.src = initialTrack.videoSrc;
                }
                
                // Monitor buffering progress
                let lastBuffered = 0;
                const bufferInterval = setInterval(() => {
                  if (video.buffered.length > 0) {
                    const bufferedEnd = video.buffered.end(0);
                    const duration = video.duration || 1;
                    const bufferedPercent = Math.round((bufferedEnd / duration) * 100);
                    
                    if (bufferedPercent > lastBuffered) {
                      lastBuffered = bufferedPercent;
                      // Only update up to 60% based on buffering
                      updateLoadingProgress(Math.min(5 + Math.round(bufferedPercent * 0.6), 65));
                    }
                    
                    // Consider it buffered enough if we've reached 15 seconds or 20%
                    if (bufferedEnd > 15 || bufferedPercent > 20) {
                      clearInterval(bufferInterval);
                      videoHasBuffer = true;
                      checkAllResourcesReady();
                    }
                  }
                }, 500);
                
                // Set timeout in case buffering takes too long
                setTimeout(() => {
                  clearInterval(bufferInterval);
                  if (!videoHasBuffer) {
                    logDebug('Video buffer timeout - proceeding anyway');
                    videoHasBuffer = true;
                    checkAllResourcesReady();
                  }
                }, 8000);
                
                // Use events to detect when video is ready
                video.addEventListener('canplaythrough', () => {
                  logDebug('Video canplaythrough event fired');
                  videoPreloaded = true;
                  updateLoadingProgress(70);
                  checkAllResourcesReady();
                }, { once: true });
                
                video.addEventListener('loadeddata', () => {
                  logDebug('Video loadeddata event fired');
                  // Sometimes canplaythrough doesn't fire
                  setTimeout(() => {
                    if (!videoPreloaded) {
                      videoPreloaded = true;
                      updateLoadingProgress(70);
                      checkAllResourcesReady();
                    }
                  }, 1000);
                }, { once: true });
                
                // Error handling
                video.addEventListener('error', (e) => {
                  logDebug('Video loading error: ' + (video.error ? video.error.message : 'unknown'));
                  // Still proceed after timeout
                  setTimeout(() => {
                    videoPreloaded = true;
                    videoHasBuffer = true;
                    updateLoadingProgress(70);
                    checkAllResourcesReady();
                  }, 3000);
                }, { once: true });
                
                // Ensure video is loading
                video.load();
                
                // Set a fallback timeout
                setTimeout(() => {
                  if (!videoPreloaded) {
                    logDebug('Video preload timeout - proceeding anyway');
                    videoPreloaded = true;
                    videoHasBuffer = true;
                    updateLoadingProgress(70);
                    checkAllResourcesReady();
                  }
                }, 10000);
              } else {
                videoPreloaded = true;
                videoHasBuffer = true;
                updateLoadingProgress(70);
              }
              
              // Ensure audio is preloaded
              if (audio && !audioPreloaded) {
                logDebug('Ensuring audio is loaded');
                
                // Check if audio needs to be loaded
                if (!audio.src && audioSrc && initialTrack && initialTrack.audioSrc) {
                  audio.src = initialTrack.audioSrc;
                  audio.load();
                }
                
                audio.addEventListener('canplaythrough', () => {
                  logDebug('Audio canplaythrough event fired');
                  audioPreloaded = true;
                  updateLoadingProgress(80);
                  checkAllResourcesReady();
                }, { once: true });
                
                // Set a fallback timeout for audio
                setTimeout(() => {
                  if (!audioPreloaded) {
                    logDebug('Audio preload timeout - proceeding anyway');
                    audioPreloaded = true;
                    updateLoadingProgress(80);
                    checkAllResourcesReady();
                  }
                }, 5000);
              } else {
                audioPreloaded = true;
                updateLoadingProgress(80);
              }
              
              // Ensure A-Frame is initialized
              ensureAFrameSceneVisibility(false);
              updateLoadingProgress(90);
              
              // Final check
              setTimeout(() => {
                xrModeReady = true;
                updateLoadingProgress(100);
                checkAllResourcesReady();
              }, 1000);
            }
            
            // Function to update loading progress
            function updateLoadingProgress(percent) {
              if (loadingProgressText) {
                loadingProgressText.textContent = `${percent}%`;
              }
            }
            
            // Function to check if all resources are ready
            function checkAllResourcesReady() {
              if (videoPreloaded && videoHasBuffer && audioPreloaded && permissionGranted && xrModeReady) {
                logDebug('All resources ready, entering XR mode');
                
                // Hide permission overlay
                permissionOverlay.classList.remove('active');
                setTimeout(() => {
                  permissionOverlay.style.display = 'none';
                  
                  // Refresh camera to pick up permissions
                  const camera = document.querySelector('a-entity[camera]');
                  if (camera && camera.components && camera.components['look-controls']) {
                    camera.components['look-controls'].pause();
                    camera.components['look-controls'].play();
                    logDebug('Camera look-controls reset after preloading');
                  }
                  
                  // Now it's safe to enter XR mode
                  enterXRMode();
                }, 300);
              }
            }
            
            // Function to enter XR mode (will be defined in setupXRButtons)
            function enterXRMode() {
              if (typeof setupXRButtons.enterXRMode === 'function') {
                setupXRButtons.enterXRMode();
              } else {
                // Fallback if the function isn't available yet
                setTimeout(() => {
                  if (launchXrBtn) {
                    // This will trigger the standard flow
                    const originalClick = launchXrBtn.onclick;
                    launchXrBtn.onclick = null; // Remove our interceptor first
                    launchXrBtn.click(); // Original click should contain the enterXRMode logic
                    launchXrBtn.onclick = originalClick; // Restore our interceptor
                  }
                }, 100);
              }
            }
          }
          
          // Check URL parameters for CMS data and auto-advance setting
          function getUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const autoAdvance = urlParams.get('autoAdvance') !== 'false'; // Default to true
            return { autoAdvance };
          }
          
          // Get URL params and check if auto-advance is enabled
          const { autoAdvance } = getUrlParams();
          logDebug(`Auto-advance is ${autoAdvance ? 'enabled' : 'disabled'}`);
          
          // Populate initial track (this would normally come from playlist-manager.js)
          const initialTrack = {
            title: "SoundHelix Demo Track",
            chapter: "Chapter 1: Open Skies",
            audioSrc: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3",
            videoSrc: "https://cmm-cloud-storage.s3.us-east-2.amazonaws.com/2025-03-08-JAPANTOWN-XR1-LOW.mp4",
            albumArt: "https://upload.wikimedia.org/wikipedia/en/7/74/Radiohead.okcomputer.albumart.jpg",
            trackOrder: 1,
            isXR: true // Set this property based on CMS data
          };
          
          // Show loading indicator during preloading
          const loadingOverlay = document.getElementById('loading-overlay');
          if (loadingOverlay) {
            loadingOverlay.classList.add('active');
            
            // Safety timeout to ensure loading overlay is always hidden eventually
            const loadingTimeout = setTimeout(() => {
              logDebug('Loading overlay safety timeout triggered');
              loadingOverlay.classList.remove('active');
              // Force with inline style as a backup
              loadingOverlay.style.opacity = '0';
              loadingOverlay.style.pointerEvents = 'none';
              setTimeout(() => {
                loadingOverlay.style.removeProperty('opacity');
                loadingOverlay.style.removeProperty('pointer-events');
              }, 1000);
            }, 8000); // 8 second maximum loading time
          }
          
          // Preload functions
          const preloadXRContent = () => {
            return new Promise((resolve, reject) => {
              const video = document.querySelector('#xr-video');
              const launchXrBtn = document.getElementById('launch-xr');
              
              // Ensure button is disabled while loading
              if (launchXrBtn) {
                launchXrBtn.disabled = true;
                launchXrBtn.textContent = 'Loading XR Content...';
              }
              
              if (!video) {
                logDebug('Video element not found during preload');
                reject(new Error('Video element not found'));
                return;
              }
              
              logDebug('Starting video preload: ' + initialTrack.videoSrc);
              
              // Listen for both canplaythrough and loadeddata events
              let resolved = false;
              const markAsResolved = () => {
                if (!resolved) {
                  resolved = true;
                  logDebug('XR video preloaded successfully');
                  // Store video buffered state
                  if (typeof SharedState !== 'undefined') {
                    SharedState.updateState({ videoBuffered: true });
                  }
                  
                  // Enable the XR button
                  if (launchXrBtn) {
                    launchXrBtn.disabled = false;
                    launchXrBtn.textContent = 'Launch XR Mode';
                    logDebug('XR button enabled - video is ready');
                  }
                  
                  resolve(video);
                }
              };
              
              // Setup error handler
              const handleError = (e) => {
                if (!resolved) {
                  const errorMessage = video.error ? 
                    `Video error code: ${video.error.code}, message: ${video.error.message}` : 
                    'Unknown video error';
                  logDebug('Error preloading XR video: ' + errorMessage);
                  console.error('Error preloading XR video:', e);
                  
                  // Still enable button after error
                  if (launchXrBtn) {
                    launchXrBtn.disabled = false;
                    launchXrBtn.textContent = 'Launch XR Mode';
                    logDebug('XR button enabled after error');
                  }
                  
                  reject(new Error(errorMessage));
                }
              };
              
              // Clear any existing sources and listeners
              video.removeAttribute('src');
              video.load();
              
              // Set up multiple event listeners for different browser behaviors
              video.addEventListener('canplaythrough', markAsResolved, { once: true });
              video.addEventListener('loadeddata', () => {
                logDebug('Video loadeddata event fired, readyState: ' + video.readyState);
                // On some browsers, this might be enough
                if (video.readyState >= 3) {
                  markAsResolved();
                }
              }, { once: true });
              
              video.addEventListener('error', handleError, { once: true });
              
              // Set the source
              video.crossOrigin = 'anonymous';
              video.src = initialTrack.videoSrc;
              video.muted = true; // Muted for autoplay capability
              logDebug('Setting video source: ' + initialTrack.videoSrc);
              
              // Force load the video
              video.load();
              logDebug('Video load triggered');
              
              // Try preloading with play/pause, but handle autoplay restrictions gracefully
              setTimeout(() => {
                if (!resolved) { // Only try if not already resolved
                  video.play().then(() => {
                    // Immediately pause after playing to preload
                    video.pause();
                    video.currentTime = 0;
                    logDebug('Video play/pause sequence completed for preloading');
                  }).catch(e => {
                    logDebug('Auto-play for preloading not allowed: ' + e.message);
                    console.warn('Auto-play for preloading not allowed:', e);
                    // This is expected on some browsers, not a critical error
                    // Check if we have enough data anyway
                    if (video.readyState >= 3) {
                      markAsResolved();
                    } else {
                      // Set a timeout to check video readiness in case events don't fire
                      setTimeout(() => {
                        if (!resolved && video.readyState >= 2) {
                          logDebug('Video preloaded via timeout check (readyState: ' + video.readyState + ')');
                          markAsResolved();
                        }
                      }, 3000);
                    }
                  });
                }
              }, 500);
              
              // Set a timeout fallback
              setTimeout(() => {
                if (!resolved) {
                  logDebug('Video preload timed out after 10 seconds, but continuing anyway');
                  
                  // Still enable the button even after timeout
                  if (launchXrBtn && launchXrBtn.disabled) {
                    launchXrBtn.disabled = false;
                    launchXrBtn.textContent = 'Launch XR Mode';
                    logDebug('XR button enabled after timeout');
                  }
                  
                  markAsResolved();
                }
              }, 10000);
            });
          };
          
          // Call this function when entering XR mode to ensure A-Frame scene is visible and working
          function ensureAFrameSceneVisibility(makeVisible = true) {
            logDebug('Ensuring A-Frame scene ' + (makeVisible ? 'visibility' : 'initialization'));
            
            const xrContainer = document.getElementById('xr-scene-container');
            if (!xrContainer) {
              logDebug('XR container not found');
              return false;
            }
            
            // Make sure A-Frame is loaded
            if (!window.AFRAME) {
              logDebug('A-Frame library not loaded');
              alert('A-Frame library is not loaded. Please refresh the page.');
              return false;
            }
            
            try {
              // Only make visible if requested
              if (makeVisible) {
                // First, remove hidden class from body
                document.body.classList.remove('xr-scene-hidden');
                logDebug('Removed xr-scene-hidden class from body');
                
                // Reset all styles to ensure visibility
                xrContainer.style.cssText = `
                  display: block !important;
                  visibility: visible !important;
                  opacity: 1 !important;
                  z-index: 9000 !important;
                  position: fixed !important;
                  top: 0 !important;
                  left: 0 !important;
                  width: 100vw !important;
                  height: 100vh !important;
                `;
                logDebug('Applied critical style overrides to XR container');
              } else {
                // Ensure it exists but keep it hidden
                xrContainer.style.cssText = `
                  display: none;
                  visibility: hidden;
                  opacity: 0;
                `;
              }
              
              // Add fallback rendering attempt if videosphere isn't rendering correctly
              const fallbackVideoSetup = () => {
                logDebug('Attempting fallback video setup');
                // Get the video element
                const video = document.getElementById('xr-video');
                const scene = xrContainer.querySelector('a-scene');
                const videosphere = scene.querySelector('a-videosphere');
                
                if (video && videosphere) {
                  // Update video properties
                  video.crossOrigin = 'anonymous';
                  
                  // Reset the videosphere
                  videosphere.removeAttribute('src');
                  
                  // Force a re-render by removing and reattaching
                  const parent = videosphere.parentNode;
                  const temp = videosphere;
                  parent.removeChild(videosphere);
                  
                  // Add it back after a short delay
                  setTimeout(() => {
                    parent.appendChild(temp);
                    temp.setAttribute('src', '#xr-video');
                    logDebug('Videosphere reattached after full reset');
                  }, 100);
                }
              };
              
              // Don't run fallback immediately if not making visible
              if (makeVisible) {
                // Schedule a fallback attempt after a short delay
                setTimeout(fallbackVideoSetup, 500);
              }
              
              // Check if A-Frame scene exists
              const scene = xrContainer.querySelector('a-scene');
              if (!scene) {
                logDebug('A-Frame scene not found');
                return false;
              }
              
              // Check if A-Frame is fully initialized
              if (!scene.hasLoaded) {
                logDebug('A-Frame scene not fully loaded yet, waiting...');
                // Wait for A-Frame to fully initialize
                return new Promise((resolve) => {
                  scene.addEventListener('loaded', () => {
                    logDebug('A-Frame scene loaded event fired');
                    // Continue once loaded
                    finishSceneSetup(scene, makeVisible);
                    resolve(true);
                  }, { once: true });
                  
                  // Set a timeout in case the event never fires
                  setTimeout(() => {
                    logDebug('A-Frame scene load timeout, continuing anyway');
                    finishSceneSetup(scene, makeVisible);
                    resolve(true);
                  }, 3000);
                });
              } else {
                // A-Frame is already initialized
                return finishSceneSetup(scene, makeVisible);
              }
              
              function finishSceneSetup(scene, makeVisible) {
                // Only make visible if requested
                if (makeVisible) {
                  // Force visibility of A-Frame scene
                  scene.style.cssText = `
                    display: block !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    width: 100% !important;
                    height: 100% !important;
                    z-index: 9001 !important;
                  `;
                  
                  // Log scene information for debugging
                  logDebug('Scene loaded state: ' + scene.hasLoaded);
                  logDebug('Scene is active: ' + scene.isPlaying);
                  
                  // Make sure canvas is visible
                  const canvas = scene.canvas;
                  if (canvas) {
                    canvas.style.cssText = `
                      display: block !important;
                      width: 100% !important;
                      height: 100% !important;
                      position: absolute !important;
                      top: 0 !important;
                      left: 0 !important;
                      z-index: 9901 !important;
                      opacity: 1 !important;
                      visibility: visible !important;
                    `;
                    logDebug('A-Frame canvas styles reset with !important flags');
                    
                    // Examine canvas properties
                    logDebug('Canvas dimensions: ' + canvas.width + 'x' + canvas.height);
                    logDebug('Canvas visibility: ' + canvas.style.visibility);
                  } else {
                    logDebug('A-Frame canvas not found');
                    return false;
                  }
                }
                
                // Force scene to resize if renderer exists
                if (scene.renderer) {
                  scene.renderer.setSize(window.innerWidth, window.innerHeight);
                  window.dispatchEvent(new Event('resize'));
                  if (typeof scene.resize === 'function') {
                    scene.resize();
                  }
                  logDebug('A-Frame renderer resized');
                } else {
                  logDebug('A-Frame renderer not available');
                }
                
                // Check and enable camera look controls
                const camera = scene.querySelector('[camera]');
                if (camera) {
                  camera.setAttribute('look-controls', 'enabled', true);
                  logDebug('A-Frame camera controls enabled');
                } else {
                  logDebug('A-Frame camera not found');
                  return false;
                }
                
                // Make sure video is properly attached to videosphere
                const videosphere = scene.querySelector('a-videosphere');
                if (videosphere) {
                  const video = document.querySelector('#xr-video');
                  if (video) {
                    // Force re-attach the video only if making visible
                    if (makeVisible) {
                      videosphere.removeAttribute('src');
                      setTimeout(() => {
                        videosphere.setAttribute('src', '#xr-video');
                        logDebug('Reattached video to videosphere');
                        
                        // Check videosphere material
                        const material = videosphere.getObject3D('mesh').material;
                        if (material) {
                          logDebug('Videosphere material exists');
                          if (material.map) {
                            logDebug('Videosphere has texture map');
                          } else {
                            logDebug('Videosphere missing texture map');
                          }
                        } else {
                          logDebug('Videosphere missing material');
                        }
                      }, 100);
                    }
                  }
                } else {
                  logDebug('A-Frame videosphere not found');
                  return false;
                }
                
                // Force redraw
                setTimeout(() => {
                  window.dispatchEvent(new Event('resize'));
                  logDebug('Forced window resize event for A-Frame');
                }, 50);
                
                return true;
              }
            } catch (e) {
              logDebug('Error setting up A-Frame scene: ' + e.message);
              console.error('Error setting up A-Frame scene:', e);
              return false;
            }
          }
          
          // Initialize the player (this would be handled by player-core.js in the full version)
          if (typeof PlayerCore !== 'undefined') {
            // Preload the XR content before initializing
            logDebug('Starting preload with PlayerCore available');
            preloadXRContent()
              .then(() => {
                PlayerCore.init(initialTrack);
                if (loadingOverlay) {
                  loadingOverlay.classList.remove('active');
                }
                logDebug('PlayerCore initialized');
                
                // Initialize recenter camera functionality
                if (typeof addRecenterCameraHandler === 'function') {
                  setTimeout(addRecenterCameraHandler, 500);
                  logDebug('Added recenter camera handler');
                }
                
                // Set up XR mode button
                setupXRButtons();
              })
              .catch(error => {
                logDebug('Error during preload: ' + error.message);
                console.error('Error during preload:', error);
                if (loadingOverlay) {
                  loadingOverlay.classList.remove('active');
                }
                PlayerCore.init(initialTrack); // Still initialize even if preload fails
                
                // Initialize recenter camera functionality even after error
                if (typeof addRecenterCameraHandler === 'function') {
                  setTimeout(addRecenterCameraHandler, 500);
                  logDebug('Added recenter camera handler after preload error');
                }
                
                // Still set up XR buttons even after preload error
                setupXRButtons();
              });
          } else {
            // Fallback for when external scripts aren't available
            logDebug('PlayerCore not available, using fallback');
            const video = document.querySelector('#xr-video');
            const audio = document.querySelector('#audio');
            const audioSrc = document.querySelector('#audio-src');
            
            // Set audio source
            audioSrc.src = initialTrack.audioSrc;
            audio.load();
            logDebug('Audio source set: ' + initialTrack.audioSrc);
            
            // Preload the XR video
            preloadXRContent()
              .then(() => {
                if (loadingOverlay) {
                  loadingOverlay.classList.remove('active');
                }
                logDebug('XR content preloaded successfully');
                
                // Set up XR buttons
                setupXRButtons();
              })
              .catch(error => {
                logDebug('Error during manual preload: ' + error.message);
                console.error('Error during manual preload:', error);
                // Still set the video source as fallback
                video.src = initialTrack.videoSrc;
                video.load();
                if (loadingOverlay) {
                  loadingOverlay.classList.remove('active');
                }
                
                // Still set up XR buttons
                setupXRButtons();
              })
              .finally(() => {
                // Update UI regardless of preload success
                document.querySelector('#track-name').textContent = initialTrack.title;
                document.querySelector('#chapter-name').textContent = initialTrack.chapter;
                document.querySelector('#album-art').src = initialTrack.albumArt;
              });
          }
          
          // Function to set up XR buttons with permission handling
          function setupXRButtons() {
            const launchXrBtn = document.getElementById('launch-xr');
            const exitXrBtn = document.getElementById('exit-xr');
            const permissionOverlay = document.getElementById('permission-overlay');
            
            if (!launchXrBtn || !exitXrBtn) {
              logDebug('XR buttons not found');
              return;
            }
            
            // Set up exit button
            exitXrBtn.addEventListener('click', function() {
              logDebug('Exit XR button clicked');
              exitXRMode();
            });
            
            // Function to enter XR mode - expose for permission system
            function enterXRMode() {
              logDebug('Entering XR mode');
              
              // Show loading indicator if we didn't come from the permission flow
              const permissionLoading = document.getElementById('permission-loading-status');
              if (loadingOverlay && !permissionLoading.style.display === 'block') {
                loadingOverlay.classList.add('active');
              }
              
              // Use a small timeout to ensure the loading overlay is shown before we start
              // heavy DOM operations
              setTimeout(() => {
                try {
                  // Make XR scene visible
                  document.body.classList.remove('xr-scene-hidden');
                  
                  // Hide album art
                  const albumArt = document.querySelector('.centered-album-art');
                  if (albumArt) {
                    albumArt.style.display = 'none';
                  }
                  
                  // Show XR scene
                  const xrContainer = document.getElementById('xr-scene-container');
                  if (xrContainer) {
                    xrContainer.style.display = 'block';
                    xrContainer.style.visibility = 'visible';
                    xrContainer.style.opacity = '1';
                  }
                  
                  // Ensure A-Frame scene is visible (true = make visible)
                  ensureAFrameSceneVisibility(true);
                  
                  // Update button visibility
                  launchXrBtn.style.display = 'none';
                  exitXrBtn.style.display = 'inline-block';
                  
                  // Show recenter button
                  const recenterBtn = document.getElementById('recenter-camera-btn');
                  if (recenterBtn) {
                    recenterBtn.style.display = 'inline-block';
                  }
                  
                  // Start video playback in sync with audio
                  startXRVideoPlayback();
                  
                  // Hide loading overlay
                  if (loadingOverlay) {
                    loadingOverlay.classList.remove('active');
                  }
                } catch (e) {
                  logDebug('Error entering XR mode: ' + e.message);
                  console.error('Error entering XR mode:', e);
                  
                  // Show error and revert to audio-only
                  alert('Error entering 360° mode. Please try again.');
                  exitXRMode();
                  
                  // Hide loading overlay
                  if (loadingOverlay) {
                    loadingOverlay.classList.remove('active');
                  }
                }
              }, 100);
            }
            
            // Function to exit XR mode
            function exitXRMode() {
              try {
                // Hide XR scene
                document.body.classList.add('xr-scene-hidden');
                
                // Hide XR container
                const xrContainer = document.getElementById('xr-scene-container');
                if (xrContainer) {
                  xrContainer.style.visibility = 'hidden';
                  xrContainer.style.display = 'none';
                }
                
                // Show album art
                const albumArt = document.querySelector('.centered-album-art');
                if (albumArt) {
                  albumArt.style.display = 'block';
                }
                
                // Update button visibility
                launchXrBtn.style.display = 'inline-block';
                exitXrBtn.style.display = 'none';
                
                // Hide recenter button
                const recenterBtn = document.getElementById('recenter-camera-btn');
                if (recenterBtn) {
                  recenterBtn.style.display = 'none';
                }
                
                // Clean up the sync interval
                if (window._xrSyncInterval) {
                  clearInterval(window._xrSyncInterval);
                  window._xrSyncInterval = null;
                  logDebug('Cleared sync interval');
                }
                
                // Stop XR video playback
                const video = document.getElementById('xr-video');
                if (video && !video.paused) {
                  video.pause();
                  
                  // Also reset the video source to prevent memory leaks and audio issues
                  const videoSrc = video.src;
                  if (videoSrc) {
                    video.removeAttribute('src');
                    video.load();
                    // Keep track of the source in case we need to restore it
                    video.dataset.lastSrc = videoSrc;
                  }
                  
                  logDebug('XR video paused and source removed');
                }
                
                // Ensure audio is unmuted and plays properly
                const audio = document.getElementById('audio');
                if (audio) {
                  audio.muted = false;
                  
                  // If audio was playing, make sure it continues
                  if (!audio.paused) {
                    // Sometimes need to restart the audio
                    const currentTime = audio.currentTime;
                    audio.pause();
                    audio.currentTime = currentTime;
                    audio.play().catch(e => logDebug('Error restarting audio: ' + e));
                  }
                }
                
                logDebug('Exited XR mode');
              } catch (e) {
                logDebug('Error exiting XR mode: ' + e.message);
                console.error('Error exiting XR mode:', e);
              }
            }
            
            // Function to start video playback synced with audio
            function startXRVideoPlayback() {
              const video = document.getElementById('xr-video');
              const audio = document.getElementById('audio');
              
              if (!video || !audio) {
                logDebug('Video or audio element not found');
                return;
              }
              
              try {
                // Ensure video has src
                if (!video.src && video.dataset.lastSrc) {
                  video.src = video.dataset.lastSrc;
                  video.load();
                }
                
                // Sync video time with audio
                video.currentTime = audio.currentTime;
                
                // Unmute video for XR mode
                video.volume = audio.volume;
                video.muted = false;
                
                // Mute audio for XR mode (to prevent echo)
                audio.muted = true;
                
                // Start video playback
                video.play().then(() => {
                  logDebug('XR video playback started');
                  
                  // Set up a sync interval to keep video in sync with audio time
                  const syncInterval = setInterval(() => {
                    if (Math.abs(video.currentTime - audio.currentTime) > 0.5) {
                      logDebug('Re-syncing video with audio');
                      video.currentTime = audio.currentTime;
                    }
                  }, 5000);
                  
                  // Store for cleanup
                  window._xrSyncInterval = syncInterval;
                  
                }).catch(e => {
                  logDebug('Error starting video: ' + e);
                  
                  // On iOS, needs user interaction first
                  const tapToStartHandler = () => {
                    video.play().catch(err => {
                      logDebug('Still cannot play video after tap: ' + err);
                    });
                    document.removeEventListener('click', tapToStartHandler);
                  };
                  
                  document.addEventListener('click', tapToStartHandler, { once: true });
                  alert('Tap the screen to enable 360° video.');
                });
              } catch (e) {
                logDebug('Error in video playback: ' + e.message);
              }
            }
            
            // Expose the enterXRMode function so it can be called from the permission flow
            setupXRButtons.enterXRMode = enterXRMode;
          }
        });
      </script>
    </div>
    
    <!-- Webflow CMS Integration Script -->
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Wait for Webflow to initialize
        if (window.Webflow && window.Webflow.push) {
          window.Webflow.push(function() {
            // Get current item data from Webflow
            const currentItem = Webflow.data.item;
            
            // Exit if no current item found
            if (!currentItem) {
              console.log('No Webflow CMS item data found, using default track');
              return;
            }
            
            console.log('Current CMS item:', currentItem);
            
            // Create track object from current item
            const currentTrack = {
              id: currentItem.id || currentItem._id,
              title: currentItem.name || 'Unknown Track',
              chapter: currentItem.chapterTitle || '',
              audioSrc: currentItem.audioSrc || currentItem.audio_src || '',
              videoSrc: currentItem.videoSrc || currentItem.XR_src || '',
              albumArt: currentItem.albumArt || '',
              trackOrder: currentItem.trackOrder || 0,
              isXR: !!currentItem.isXR // Convert to boolean value
            };
            
            // Load current track
            if (typeof PlayerCore !== 'undefined') {
              PlayerCore.loadTrack(currentTrack);
              console.log('Loaded current track:', currentTrack);
            }
            
            // Now fetch all tracks from the same collection for the playlist
            fetchAllCollectionItems(currentItem.collection_id, currentTrack.id);
          });
        }
        
        // Function to fetch all items from the same collection
        function fetchAllCollectionItems(collectionId, currentItemId) {
          // Check if we're on a Webflow site with collection APIs
          if (!collectionId || typeof Webflow === 'undefined') {
            console.error('Cannot fetch collection items - missing collection ID or Webflow API');
            return;
          }
          
          // Construct API URL for the collection
          const apiUrl = `/api/collections/${collectionId}/items?limit=100`;
          
          // Fetch all items
          fetch(apiUrl)
            .then(response => {
              if (!response.ok) throw new Error('Failed to fetch collection items');
              return response.json();
            })
            .then(data => {
              if (!data.items || !Array.isArray(data.items)) {
                throw new Error('Invalid collection items data');
              }
              
              // Transform items into playlist tracks
              const tracks = data.items.map(item => ({
                id: item.id || item._id,
                title: item.name || 'Unknown Track',
                chapter: item.chapterTitle || '',
                audioSrc: item.audioSrc || item.audio_src || '',
                videoSrc: item.videoSrc || item.XR_src || '',
                albumArt: item.albumArt || '',
                trackOrder: item.trackOrder || 0,
                isXR: !!item.isXR, // Convert to boolean value
                // Store URL to this item's page for playlist navigation
                itemUrl: item.slug ? `/${item.slug}` : null
              }));
              
              // Sort tracks by trackOrder if available
              tracks.sort((a, b) => {
                if (a.trackOrder && b.trackOrder) {
                  return a.trackOrder - b.trackOrder;
                }
                return 0; // Keep original order if no trackOrder
              });
              
              // Find index of current track
              const currentIndex = tracks.findIndex(track => track.id === currentItemId);
              
              // Create playlist object
              const playlist = {
                name: "Audio Experience",
                tracks: tracks,
                currentIndex: currentIndex >= 0 ? currentIndex : 0
              };
              
              console.log('Created playlist with', tracks.length, 'tracks');
              
              // Initialize the playlist
              if (typeof PlaylistManager !== 'undefined') {
                PlaylistManager.init(playlist);
                
                // Set custom navigation to use item URLs
                PlaylistManager.setPreviousCallback(() => {
                  const prevIndex = currentIndex - 1;
                  if (prevIndex >= 0 && tracks[prevIndex] && tracks[prevIndex].itemUrl) {
                    window.location.href = tracks[prevIndex].itemUrl;
                  }
                });
                
                PlaylistManager.setNextCallback(() => {
                  const nextIndex = currentIndex + 1;
                  if (nextIndex < tracks.length && tracks[nextIndex] && tracks[nextIndex].itemUrl) {
                    window.location.href = tracks[nextIndex].itemUrl;
                  }
                });
                
                // Populate playlist UI
                populatePlaylistUI(tracks, currentItemId);
              }
            })
            .catch(error => {
              console.error('Error fetching collection items:', error);
            });
        }
        
        // Function to populate the playlist UI
        function populatePlaylistUI(tracks, currentItemId) {
          const playlistContainer = document.getElementById('playlist-tracks');
          if (!playlistContainer) return;
          
          // Clear existing items
          playlistContainer.innerHTML = '';
          
          // Add tracks to playlist UI
          tracks.forEach((track, index) => {
            const li = document.createElement('li');
            if (track.id === currentItemId) {
              li.classList.add('active');
            }
            
            li.innerHTML = `
              <div class="track-title">${track.trackOrder ? `${track.trackOrder}. ` : ''}${track.title}</div>
              <div class="track-chapter">${track.chapter}</div>
            `;
            
            // Add click handler to navigate to track
            li.addEventListener('click', () => {
              // Exit XR mode before navigating to new track
              if (typeof XRController !== 'undefined' && XRController.isInXRMode()) {
                console.log('Exiting XR mode before navigating to selected track');
                XRController.exitXRMode();
              }
              
              if (track.itemUrl) {
                window.location.href = track.itemUrl;
              }
            });
            
            playlistContainer.appendChild(li);
          });
        }
      });
    </script>

    <!-- Add helper function for recenter camera -->
    <script>
      // Add recenter camera functionality that will be available globally
      function addRecenterCameraHandler() {
        const recenterBtn = document.getElementById('recenter-camera-btn');
        if (!recenterBtn) return;
        
        // Clear any existing event listeners
        const newButton = recenterBtn.cloneNode(true);
        recenterBtn.parentNode.replaceChild(newButton, recenterBtn);
        
        // Add event listener to the new button
        newButton.addEventListener('click', function() {
          console.log('Recenter camera button clicked');
          
          // First try to use the global recenterCamera function if available
          if (typeof recenterCamera === 'function') {
            recenterCamera();
            // Flash feedback to user
            this.classList.add('active');
            setTimeout(() => {
              this.classList.remove('active');
            }, 300);
            return;
          }
          
          // Fallback to direct camera manipulation if global function not available
          const scene = document.querySelector('a-scene');
          if (!scene) {
            console.log('Scene not found for recenter');
            return;
          }
          
          const camera = scene.querySelector('[camera]');
          if (!camera) {
            console.log('Camera not found for recenter');
            return;
          }
          
          // Reset camera rotation
          camera.setAttribute('rotation', '0 0 0');
          
          // Flash feedback to user
          this.classList.add('active');
          setTimeout(() => {
            this.classList.remove('active');
          }, 300);
          
          // If using look-controls, also reset their state
          if (camera.components && camera.components['look-controls']) {
            const lookControls = camera.components['look-controls'];
            if (lookControls) {
              try {
                // Reset rotation objects manually
                if (lookControls.pitchObject) lookControls.pitchObject.rotation.x = 0;
                if (lookControls.yawObject) lookControls.yawObject.rotation.y = 0;
                console.log('Camera look controls reset');
              } catch (e) {
                console.error('Error resetting camera look controls:', e);
              }
            }
          }
          
          console.log('Camera reset completed');
        });
        
        console.log('Recenter camera handler added');
      }
      
      // Ensure A-Frame scene is properly initialized
      function initializeAFrameScene() {
        console.log('Initializing A-Frame scene');
        const xrContainer = document.getElementById('xr-scene-container');
        if (!xrContainer) return false;
        
        const scene = xrContainer.querySelector('a-scene');
        if (!scene) return false;
        
        // Force scene to be hidden but initialized
        document.body.classList.add('xr-scene-hidden');
        
        // Handle scene loaded event
        const isLoaded = scene.hasLoaded;
        if (!isLoaded) {
          scene.addEventListener('loaded', function() {
            console.log('A-Frame scene loaded event fired');
            finishSceneSetup(scene);
          });
        } else {
          finishSceneSetup(scene);
        }
        
        function finishSceneSetup(scene) {
          // Initialize video element
          const video = document.getElementById('xr-video');
          if (video) {
            video.setAttribute('crossorigin', 'anonymous');
            video.crossOrigin = 'anonymous';
          }
          
          // Ensure camera has look-controls
          const camera = scene.querySelector('[camera]');
          if (camera) {
            camera.setAttribute('look-controls', 'enabled: true; reverseMouseDrag: false');
          }
          
          // Add camera reset handler
          addRecenterCameraHandler();
          
          console.log('A-Frame scene initialization complete');
          return true;
        }
        
        return true;
      }
      
      // Call this function after DOM is loaded and again when entering XR mode
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize A-Frame scene first
        setTimeout(initializeAFrameScene, 300);
        
        // Then add recenter handler
        setTimeout(addRecenterCameraHandler, 800);
      });
    </script>

    <!-- Failsafe mechanism to ensure critical functions are available -->
    <script>
      // Add a window load event that checks and reinstates any missing functionality
      window.addEventListener('load', function() {
        // Check XR button state
        const launchXrBtn = document.getElementById('launch-xr');
        const video = document.getElementById('xr-video');
        
        if (launchXrBtn && video) {
          // Ensure button state is correct based on video readiness
          if (video.readyState >= 3) {
            launchXrBtn.disabled = false;
            launchXrBtn.textContent = 'Launch XR Mode';
            console.log('XR button enabled by window load handler');
          }
          
          // Add a click listener to the document to handle user interaction
          // requirements for video loading in some browsers
          document.addEventListener('click', function() {
            // After user interaction, try to preload video again if needed
            if (launchXrBtn.disabled && video.readyState < 3) {
              console.log('User interaction detected, trying to load video');
              video.load();
              setTimeout(() => {
                if (video.readyState >= 3) {
                  launchXrBtn.disabled = false;
                  launchXrBtn.textContent = 'Launch XR Mode';
                  console.log('XR button enabled after user interaction');
                }
              }, 1000);
            }
          }, { once: true });
          
          // Safety timeout to ensure button becomes enabled eventually
          setTimeout(() => {
            if (launchXrBtn.disabled) {
              launchXrBtn.disabled = false;
              launchXrBtn.textContent = 'Launch XR Mode';
              console.log('XR button enabled by failsafe timeout');
            }
          }, 20000);
        }
        
        // Check if recenterCamera function exists, if not, create it
        if (typeof recenterCamera !== 'function') {
          console.log('Adding failsafe recenterCamera function');
          
          window.recenterCamera = function() {
            console.log('Failsafe recenter camera function called');
            
            try {
              // Get the A-Frame scene and camera
              const scene = document.querySelector('a-scene');
              if (!scene) return false;
              
              const camera = scene.querySelector('[camera]');
              if (!camera) return false;
              
              // Reset camera rotation
              camera.setAttribute('rotation', '0 0 0');
              
              // Try to reset look-controls
              if (camera.components && camera.components['look-controls']) {
                const lookControls = camera.components['look-controls'];
                if (lookControls) {
                  if (lookControls.pitchObject) lookControls.pitchObject.rotation.x = 0;
                  if (lookControls.yawObject) lookControls.yawObject.rotation.y = 0;
                }
              }
              
              return true;
            } catch (e) {
              console.error('Error in failsafe recenterCamera:', e);
              return false;
            }
          };
        }
        
        // Check if the recenter button has event listeners, if not add them
        const recenterBtn = document.getElementById('recenter-camera-btn');
        if (recenterBtn) {
          // Force add event listener that uses our global function
          recenterBtn.addEventListener('click', function() {
            console.log('Failsafe recenter button clicked');
            
            // Use the global recenterCamera function
            if (typeof recenterCamera === 'function') {
              recenterCamera();
            }
            
            // Visual feedback
            this.classList.add('active');
            setTimeout(() => {
              this.classList.remove('active');
            }, 300);
          });
        }
        
        // Enable A-Frame scene camera look controls if needed
        setTimeout(function() {
          const scene = document.querySelector('a-scene');
          if (scene) {
            const camera = scene.querySelector('[camera]');
            if (camera) {
              camera.setAttribute('look-controls', 'enabled: true; reverseMouseDrag: false');
              console.log('Failsafe camera look-controls enabled');
            }
          }
        }, 1000);
      });
    </script>

    <!-- Add iframe message listener for CMS integration -->
    <script>
      // Handle messages from parent window (CMS page)
      window.addEventListener('message', function(event) {
        // Security check - only accept messages from allowed domains
        // You should update this to match your CMS domain
        const allowedOrigins = [
          'https://xrwalkingtour.com',       // Main domain
          'https://*.xrwalkingtour.com',     // Any subdomain
          'http://xrwalkingtour.com',        // Non-HTTPS version (if needed)
          'http://*.xrwalkingtour.com',      // Non-HTTPS subdomains (if needed)
          'http://localhost:3000'            // For local development
        ];
        
        // Check if origin is allowed or matches wildcard pattern
        const isAllowed = allowedOrigins.some(pattern => {
          if (pattern.includes('*')) {
            // For wildcard patterns, convert to regex
            const regexPattern = pattern.replace(/\./g, '\\.').replace(/\*/g, '.*');
            const regex = new RegExp(`^${regexPattern}$`);
            return regex.test(event.origin);
          }
          return pattern === event.origin;
        });
        
        // Skip if origin not allowed and not in development mode
        if (!isAllowed && !location.hostname.includes('localhost')) {
          console.log('Message from disallowed origin rejected:', event.origin);
          return;
        }
        
        console.log('Received message from parent:', event.data);
        
        // Check if message contains CMS data
        if (event.data && event.data.type === 'cmsData') {
          const cmsData = event.data.content;
          
          // Process track data from CMS
          if (cmsData) {
            // Create track object from CMS data
            const cmsTrack = {
              id: cmsData.id || cmsData._id || 'default-id',
              title: cmsData.name || cmsData.title || 'Unknown Track',
              chapter: cmsData.chapterTitle || cmsData.chapter || '',
              audioSrc: cmsData.audioSrc || cmsData.audio_src || '',
              videoSrc: cmsData.videoSrc || cmsData.XR_src || '',
              albumArt: cmsData.albumArt || cmsData.album_art || '',
              trackOrder: cmsData.trackOrder || 0,
              isXR: !!cmsData.isXR || !!cmsData.XR_src, // Convert to boolean value
              // Store navigation links if available
              previousTrackLink: cmsData.previousTrackLink || '',
              nextTrackLink: cmsData.nextTrackLink || ''
            };
            
            console.log('Processing CMS track data:', cmsTrack);
            
            // Load track through PlayerCore if available
            if (typeof PlayerCore !== 'undefined') {
              PlayerCore.loadTrack(cmsTrack);
              console.log('Loaded track from iframe message');
            } else {
              // Fallback: Store data for when PlayerCore initializes
              window._pendingCmsTrack = cmsTrack;
              console.log('Stored track data for later loading');
            }
            
            // Send confirmation back to parent window
            event.source.postMessage({
              type: 'playerReady',
              status: 'success',
              message: 'Track data received and processed'
            }, event.origin);
          }
        }
      });
      
      // Notify parent when player is fully loaded and ready to receive messages
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(() => {
          // Send a message to the parent window when player is ready
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'playerReady',
              status: 'ready',
              message: 'Player is ready to receive data',
              playerId: document.location.href
            }, '*'); // We use * as we don't know the parent origin yet
            
            console.log('Sent ready message to parent window');
          }
        }, 1000); // Small delay to ensure everything is loaded
      });
      
      // Check for the pending track when PlayerCore is initialized
      document.addEventListener('playerCoreInitialized', function() {
        if (window._pendingCmsTrack && typeof PlayerCore !== 'undefined') {
          PlayerCore.loadTrack(window._pendingCmsTrack);
          console.log('Loaded pending CMS track after PlayerCore initialization');
          delete window._pendingCmsTrack;
        }
      });
    </script>
  </body>
</html>