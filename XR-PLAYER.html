<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Immersive Audio Player</title>
    <!-- Added mobile-web-app-capable and apple-mobile-web-app-capable for fullscreen experience -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js"></script>
    <!-- External CSS -->
    <link rel="stylesheet" href="player-layout.css">
    <link rel="stylesheet" href="player-controls.css">
    <!-- Inline CSS for components not in external files -->
    <style>
      /* Global styles to prevent scrolling */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: fixed;
        touch-action: none;
        -webkit-overflow-scrolling: none;
      }
      
      /* Base container styles */
      .immersive-track-container {
        font-family: sans-serif;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: linear-gradient(135deg, #2c3e50, #4ca1af);
        touch-action: none;
      }

      /* XR scene specific styles - Critical z-index adjustments */
      .xr-scene {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9000 !important; /* Super high z-index to ensure visibility */
        pointer-events: auto;
        background-color: transparent !important;
        display: block !important;
        opacity: 1 !important;
      }
      
      /* When body has this class, ensure all A-Frame elements are completely hidden */
      body.xr-scene-hidden .xr-scene,
      body.xr-scene-hidden a-scene,
      body.xr-scene-hidden .a-canvas {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
      }
      
      /* When body does NOT have this class, ensure XR elements can be visible */
      body:not(.xr-scene-hidden) .xr-scene {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      body:not(.xr-scene-hidden) a-scene,
      body:not(.xr-scene-hidden) .a-canvas {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      /* Hide A-Frame attribution and VR button */
      .a-enter-ar, .a-enter-vr, .a-orientation-modal, .a-dialog-allow-button {
        display: none !important;
      }
      
      /* Ensure A-Frame canvas is visible and properly positioned */
      .a-canvas {
        position: absolute !important;
        left: 0 !important;
        top: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important; 
        height: 100% !important;
        z-index: 9001 !important; /* Canvas needs highest z-index */
        display: block !important;
        background-color: transparent !important;
        opacity: 1 !important;
        visibility: visible !important;
      }
      
      /* Centered album art */
      .centered-album-art {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: calc(100% - 40px); /* Fill available width with padding */
        max-width: 100vh; /* Prevent extremely wide displays from stretching too much */
        /* Height calculation ensures no overlap with controls */
        height: min(calc(100vh - 200px), calc(100vw - 40px));
        max-height: calc(100vh - 200px); /* Ensure it doesn't overlap with controls */
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 2;
      }
      
      .centered-album-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      /* Loading overlay */
      .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        z-index: 10000; /* Super high z-index */
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .loading-overlay.active {
        opacity: 1;
        pointer-events: all;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      /* Player controls need to be above everything except the XR scene */
      .audio-controls {
        position: absolute;
        z-index: 9500 !important;
      }
      
      /* XR buttons need to be above everything except loading overlay */
      .xr-buttons {
        position: absolute;
        z-index: 9900 !important;
      }
      
      /* Debug info */
      .debug-info {
        position: fixed;
        bottom: 15px;
        left: 15px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 10500;
        max-width: 300px;
        word-break: break-all;
      }
      
      /* Custom permission overlay for iOS */
      .permission-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.9);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        z-index: 20000;
        padding: 20px;
        text-align: center;
      }
      
      .permission-overlay.active {
        display: flex;
      }
      
      .permission-icon {
        width: 60px;
        height: 60px;
        margin-bottom: 20px;
        animation: pulse 1.5s infinite;
      }
      
      .permission-title {
        font-size: 20px;
        margin-bottom: 15px;
        font-weight: bold;
      }
      
      .permission-message {
        margin-bottom: 25px;
        max-width: 280px;
        line-height: 1.5;
      }
      
      .permission-button {
        background-color: #1DB954;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 24px;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      
      .permission-button:hover {
        background-color: #1ED760;
      }
      
      @keyframes pulse {
        0% { transform: scale(1); opacity: 0.8; }
        50% { transform: scale(1.1); opacity: 1; }
        100% { transform: scale(1); opacity: 0.8; }
      }
      
      /* Responsive adjustments */
      @media (max-width: 480px) {
        .centered-album-art {
          width: calc(100% - 30px);
          height: min(calc(100vh - 180px), calc(100vw - 30px));
        }
      }
      
      /* Landscape mode for mobile devices */
      @media (max-height: 500px) and (orientation: landscape) {
        .centered-album-art {
          width: 70%;
          height: calc(100vh - 150px);
          max-height: 60vh;
          top: calc(50% - 20px);
        }
      }
      
      /* Playlist Button in Controls */
      .playlist-btn {
        margin-right: 8px;
      }
      
      .playlist-btn svg {
        width: 24px;
        height: 24px;
      }
      
      /* Playlist Overlay Styles */
      .playlist-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 9600;
        display: none;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .playlist-overlay.active {
        display: flex;
        opacity: 1;
      }
      
      .playlist-container {
        background-color: #2c3e50;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        border-radius: 12px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }
      
      .playlist-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        background-color: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      .playlist-header h3 {
        color: white;
        margin: 0;
        font-size: 18px;
      }
      
      .close-playlist-btn {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }
      
      .close-playlist-btn:hover {
        opacity: 1;
      }
      
      .playlist-tracks {
        list-style: none;
        margin: 0;
        padding: 0;
        overflow-y: auto;
        max-height: calc(80vh - 60px);
      }
      
      .playlist-tracks li {
        padding: 12px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        transition: background-color 0.2s ease;
      }
      
      .playlist-tracks li:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }
      
      .playlist-tracks li.active {
        background-color: rgba(76, 161, 175, 0.3);
      }
      
      .track-title {
        font-weight: bold;
        margin-bottom: 4px;
      }
      
      .track-chapter {
        font-size: 0.8em;
        opacity: 0.7;
      }
      
      /* Responsive adjustments for playlist */
      @media (max-width: 480px) {
        .playlist-container {
          width: 95%;
          max-height: 90vh;
        }
      }
      
      @media (max-height: 500px) and (orientation: landscape) {
        .playlist-container {
          max-height: 80vh;
        }
      }
      
      /* Prevent text selection during scrubbing */
      body.scrubbing-in-progress {
        user-select: none;
        -webkit-user-select: none;
        cursor: grabbing;
      }
      
      /* Improve visual feedback when scrubbing */
      .progress-bar.scrubbing .progress-filled {
        background-color: #1ED760; /* Brighter green when active */
        transition: none; /* Remove transition for immediate feedback */
      }
      
      /* Make progress bar more responsive to hover */
      .progress-bar:hover {
        background-color: rgba(255, 255, 255, 0.3);
      }
      
      /* Add a subtle transition for hover effects */
      .progress-bar, .progress-filled, .progress-filled::after {
        transition: all 0.15s ease;
      }
      
      /* Recenter camera button styles */
      #recenter-camera-btn {
        transition: background-color 0.3s ease, transform 0.2s ease;
      }
      
      #recenter-camera-btn:active {
        transform: scale(0.95);
      }
      
      #recenter-camera-btn.active {
        background-color: #1DB954 !important;
      }

      /* XR button styles */
      #launch-xr {
        position: relative;
        transition: all 0.3s ease;
      }

      #launch-xr:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background-color: #888;
      }
      
      #launch-xr:disabled::after {
        content: '';
        display: inline-block;
        width: 10px;
        height: 10px;
        margin-left: 8px;
        border: 2px solid rgba(255,255,255,0.7);
        border-top-color: transparent;
        border-radius: 50%;
        animation: xr-button-loading 1s linear infinite;
        vertical-align: middle;
      }
      
      @keyframes xr-button-loading {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="immersive-track-container" id="player-container">
      <!-- Centered Album Art -->
      <div class="centered-album-art">
        <img id="album-art" alt="Album Art">
      </div>

      <!-- XR Scene Container - This needs to be above all other elements -->
      <div id="xr-scene-container" class="xr-scene">
        <a-scene
          xr-mode-ui="enabled: false"
          vr-mode-ui="enabled: false"
          renderer="antialias: true; colorManagement: true; precision: high; logarithmicDepthBuffer: true;"
          embedded
          loading-screen="enabled: false"
          device-orientation-permission-ui="enabled: true"
          inspector="url: https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js"
        >
          <a-assets timeout="30000">
            <video id="xr-video" preload="auto" crossorigin="anonymous" playsinline webkit-playsinline loop muted></video>
          </a-assets>
          <a-videosphere src="#xr-video" rotation="0 -90 0" radius="100" segments-height="64" segments-width="64"></a-videosphere>
          <a-entity camera look-controls="magicWindowTrackingEnabled: true; touchEnabled: true; mouseEnabled: true; reverseMouseDrag: false" position="0 1.6 0" wasd-controls="enabled: false"></a-entity>
        </a-scene>
      </div>

      <!-- Player Controls Section -->
      <div class="audio-controls">
        <div class="track-info">
          <h4 id="track-name"></h4>
          <p id="chapter-name"></p>
          <div class="player-progress">
            <div class="progress-bar">
              <div class="progress-filled"></div>
            </div>
            <div class="time-display">
              <span id="current-time">0:00</span>
              <span id="duration">0:00</span>
            </div>
          </div>
          <div class="playback-controls">
            <button id="playlist-btn" class="control-btn playlist-btn" title="Show playlist">
              <svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/>
              </svg>
            </button>
            <button id="rewind-btn" class="control-btn rewind-btn" title="Rewind 10 seconds">
              <span class="time-shift-value">-10s</span>
              <svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M12.5,3C17.15,3 21.08,6.03 22.47,10.22L20.1,11C19.05,7.81 16.04,5.5 12.5,5.5C10.54,5.5 8.77,6.22 7.38,7.38L10,10H3V3L5.6,5.6C7.45,4 9.85,3 12.5,3M10,12V22H8V14H6V12H10M18,14V20C18,21.11 17.11,22 16,22H14A2,2 0 0,1 12,20V14A2,2 0 0,1 14,12H16C17.11,12 18,12.9 18,14M14,14V20H16V14H14M11.5,3C14.15,3 16.55,4 18.4,5.6L21,3V10H14L16.62,7.38C15.23,6.22 13.46,5.5 11.5,5.5C7.96,5.5 4.95,7.81 3.9,11L1.53,10.22C2.92,6.03 6.85,3 11.5,3Z"/>
              </svg>
            </button>
            <button id="play-pause-btn" class="control-btn play-pause-btn">
              <svg class="play-icon" viewBox="0 0 24 24">
                <path fill="currentColor" d="M8 5v14l11-7z"/>
              </svg>
              <svg class="pause-icon" viewBox="0 0 24 24" style="display: none;">
                <path fill="currentColor" d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
              </svg>
            </button>
            <button id="forward-btn" class="control-btn forward-btn" title="Forward 10 seconds">
              <span class="time-shift-value">+10s</span>
              <svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M10,12V22H8V14H6V12H10M18,14V20C18,21.11 17.11,22 16,22H14A2,2 0 0,1 12,20V14A2,2 0 0,1 14,12H16C17.11,12 18,12.9 18,14M14,14V20H16V14H14M11.5,3C14.15,3 16.55,4 18.4,5.6L21,3V10H14L16.62,7.38C15.23,6.22 13.46,5.5 11.5,5.5C7.96,5.5 4.95,7.81 3.9,11L1.53,10.22C2.92,6.03 6.85,3 11.5,3Z"/>
              </svg>
            </button>
            <button id="mute-btn" class="control-btn mute-btn" title="Toggle mute">
              <svg class="volume-icon" viewBox="0 0 24 24">
                <path fill="currentColor" d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"/>
              </svg>
              <svg class="mute-icon" viewBox="0 0 24 24" style="display: none;">
                <path fill="currentColor" d="M12,4L9.91,6.09L12,8.18V4M4.27,3L3,4.27L7.73,9H3V15H7L12,20V13.27L16.25,17.53C15.58,18.04 14.83,18.46 14,18.7V20.77C15.38,20.45 16.63,19.82 17.68,18.96L19.73,21L21,19.73L12,10.73L4.27,3M19,12C19,12.94 18.8,13.82 18.46,14.64L19.97,16.15C20.62,14.91 21,13.5 21,12C21,7.72 18,4.14 14,3.23V5.29C16.89,6.15 19,8.83 19,12M16.5,12C16.5,10.23 15.5,8.71 14,7.97V10.18L16.45,12.63C16.5,12.43 16.5,12.21 16.5,12Z"/>
              </svg>
            </button>
            <audio id="audio" preload="metadata">
              <source id="audio-src" type="audio/mpeg">
              Your browser does not support the audio element.
            </audio>
          </div>
        </div>
      </div>

      <!-- Playlist Overlay -->
      <div id="playlist-overlay" class="playlist-overlay">
        <div class="playlist-container">
          <div class="playlist-header">
            <h3>Playlist</h3>
            <button id="close-playlist-btn" class="close-playlist-btn">×</button>
          </div>
          <ul id="playlist-tracks" class="playlist-tracks">
            <!-- Playlist items will be dynamically inserted here -->
          </ul>
        </div>
      </div>

      <div class="xr-buttons" id="xr-controls">
        <button id="launch-xr" disabled>Loading XR Content...</button>
        <button id="exit-xr" style="display: none;">Exit XR</button>
        <button id="recenter-camera-btn" style="display: none;">Recenter Camera</button>
      </div>

      <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div>Loading immersive experience...</div>
      </div>
      
      <!-- Custom device orientation permission overlay, primarily for iOS -->
      <div class="permission-overlay" id="permission-overlay">
        <div class="permission-icon">
          <svg viewBox="0 0 24 24" fill="white">
            <path d="M4,6H20V16H4M20,18A2,2 0 0,0 22,16V6C22,4.89 21.1,4 20,4H4C2.89,4 2,4.89 2,6V16A2,2 0 0,0 4,18H0V20H24V18H20Z" />
          </svg>
        </div>
        <div class="permission-title">Device Motion Required</div>
        <div class="permission-message">
          To experience 360° content, we need permission to use your device's motion sensors.
        </div>
        <button id="request-permission-btn" class="permission-button">Enable 360° Viewing</button>
      </div>
      
      <!-- Debug info panel -->
      <div class="debug-info" id="debug-info"></div>

      <!-- External JS - Import in this order -->
      <script src="shared-state.js"></script>
      <script src="media-preloader.js"></script>
      <script src="playlist-manager.js"></script>
      <script src="player-core.js"></script>
      <script src="player-controls.js"></script>
      <script src="xr-mode.js"></script>

      <!-- Initialize Player -->
      <script>
        document.addEventListener('DOMContentLoaded', () => {
          // Set the initial state to hide XR scene
          document.body.classList.add('xr-scene-hidden');
          
          // Disable all scrolling
          document.body.addEventListener('touchmove', function(e) {
            e.preventDefault();
          }, { passive: false });
          
          document.body.addEventListener('wheel', function(e) {
            e.preventDefault();
          }, { passive: false });
          
          // Enable debug mode for troubleshooting
          const DEBUG = true;
          const debugInfo = document.getElementById('debug-info');
          
          // Helper function to log debug info
          function logDebug(message) {
            if (!DEBUG) return;
            console.log(message);
            if (debugInfo) {
              debugInfo.style.display = 'block';
              debugInfo.innerHTML += message + '<br>';
              // Keep only last 10 messages instead of 5 for more context
              const lines = debugInfo.innerHTML.split('<br>');
              if (lines.length > 11) {
                debugInfo.innerHTML = lines.slice(lines.length - 11).join('<br>');
              }
            }
          }
          
          // Device detection
          const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
          
          logDebug(`Device detection: Mobile=${isMobile}, iOS=${isIOS}`);
          
          // Handle device orientation permission request (primarily for iOS)
          function setupDeviceOrientationPermission() {
            const permissionOverlay = document.getElementById('permission-overlay');
            const requestPermissionBtn = document.getElementById('request-permission-btn');
            
            // Only needed for iOS 13+
            if (!isIOS) return;
            
            logDebug('Setting up iOS device orientation permission handler');
            
            // Check if we need permission
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
              
              // Button to request permission
              requestPermissionBtn.addEventListener('click', () => {
                logDebug('Permission button clicked');
                
                DeviceOrientationEvent.requestPermission()
                  .then(response => {
                    if (response === 'granted') {
                      logDebug('Device orientation permission granted');
                      permissionOverlay.classList.remove('active');
                      
                      // If we have entered XR mode already, reattach look controls
                      const camera = document.querySelector('a-entity[camera]');
                      if (camera) {
                        camera.components['look-controls'].pause();
                        camera.components['look-controls'].play();
                        logDebug('Camera look-controls reset after permission');
                      }
                    } else {
                      logDebug(`Permission response: ${response}`);
                      alert('360° viewing requires motion sensor permission');
                    }
                  })
                  .catch(error => {
                    logDebug(`Permission error: ${error}`);
                    alert('Could not access motion sensors. Please try again.');
                  });
              });
            }
          }
          
          // Check URL parameters for CMS data and auto-advance setting
          function getUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const autoAdvance = urlParams.get('autoAdvance') !== 'false'; // Default to true
            return { autoAdvance };
          }
          
          // Get URL params and check if auto-advance is enabled
          const { autoAdvance } = getUrlParams();
          logDebug(`Auto-advance is ${autoAdvance ? 'enabled' : 'disabled'}`);
          
          // Initialize permission handling
          setupDeviceOrientationPermission();
          
          // Populate initial track (this would normally come from playlist-manager.js)
          const initialTrack = {
            title: "SoundHelix Demo Track",
            chapter: "Chapter 1: Open Skies",
            audioSrc: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3",
            videoSrc: "https://cmm-cloud-storage.s3.us-east-2.amazonaws.com/2025-03-08-JAPANTOWN-XR1-LOW.mp4",
            albumArt: "https://upload.wikimedia.org/wikipedia/en/7/74/Radiohead.okcomputer.albumart.jpg",
            trackOrder: 1,
            isXR: true // Set this property based on CMS data
          };
          
          // Show loading indicator during preloading
          const loadingOverlay = document.getElementById('loading-overlay');
          if (loadingOverlay) {
            loadingOverlay.classList.add('active');
            
            // Safety timeout to ensure loading overlay is always hidden eventually
            const loadingTimeout = setTimeout(() => {
              logDebug('Loading overlay safety timeout triggered');
              loadingOverlay.classList.remove('active');
              // Force with inline style as a backup
              loadingOverlay.style.opacity = '0';
              loadingOverlay.style.pointerEvents = 'none';
              setTimeout(() => {
                loadingOverlay.style.removeProperty('opacity');
                loadingOverlay.style.removeProperty('pointer-events');
              }, 1000);
            }, 8000); // 8 second maximum loading time
          }
          
          // Preload functions
          const preloadXRContent = () => {
            return new Promise((resolve, reject) => {
              const video = document.querySelector('#xr-video');
              const launchXrBtn = document.getElementById('launch-xr');
              
              // Ensure button is disabled while loading
              if (launchXrBtn) {
                launchXrBtn.disabled = true;
                launchXrBtn.textContent = 'Loading XR Content...';
              }
              
              if (!video) {
                logDebug('Video element not found during preload');
                reject(new Error('Video element not found'));
                return;
              }
              
              logDebug('Starting video preload: ' + initialTrack.videoSrc);
              
              // Configure video for mobile
              video.setAttribute('playsinline', '');
              video.setAttribute('webkit-playsinline', '');
              video.setAttribute('crossorigin', 'anonymous');
              video.crossOrigin = 'anonymous';
              
              // Listen for both canplaythrough and loadeddata events
              let resolved = false;
              const markAsResolved = () => {
                if (!resolved) {
                  resolved = true;
                  logDebug('XR video preloaded successfully');
                  // Store video buffered state
                  if (typeof SharedState !== 'undefined') {
                    SharedState.updateState({ videoBuffered: true });
                  }
                  
                  // Enable the XR button
                  if (launchXrBtn) {
                    launchXrBtn.disabled = false;
                    launchXrBtn.textContent = 'Launch XR Mode';
                    logDebug('XR button enabled - video is ready');
                  }
                  
                  resolve(video);
                }
              };
              
              // Setup error handler
              const handleError = (e) => {
                if (!resolved) {
                  const errorMessage = video.error ? 
                    `Video error code: ${video.error.code}, message: ${video.error.message}` : 
                    'Unknown video error';
                  logDebug('Error preloading XR video: ' + errorMessage);
                  console.error('Error preloading XR video:', e);
                  
                  // Try alternative loading method for mobile
                  if (isMobile) {
                    tryMobileVideoFallback(video, initialTrack.videoSrc)
                      .then(() => markAsResolved())
                      .catch(err => reject(new Error(errorMessage)));
                  } else {
                    reject(new Error(errorMessage));
                  }
                }
              };
              
              // Clear any existing sources and listeners
              video.removeAttribute('src');
              video.load();
              
              // Set up multiple event listeners for different browser behaviors
              video.addEventListener('canplaythrough', markAsResolved, { once: true });
              video.addEventListener('loadeddata', () => {
                logDebug('Video loadeddata event fired, readyState: ' + video.readyState);
                // On some browsers, this might be enough
                if (video.readyState >= 3) {
                  markAsResolved();
                }
              }, { once: true });
              
              video.addEventListener('error', handleError, { once: true });
              
              // Set the source
              video.crossOrigin = 'anonymous';
              video.src = initialTrack.videoSrc;
              video.muted = true; // Muted for autoplay capability
              logDebug('Setting video source: ' + initialTrack.videoSrc);
              
              // Force load the video
              video.load();
              logDebug('Video load triggered');
              
              // Mobile-specific loading approach
              if (isMobile) {
                // On mobile, we won't try playing the video yet, just load
                // Instead we'll wait for user interaction before trying to play
                logDebug('Using mobile-optimized loading approach');
                
                // Set a timeout to check if loaded to a reasonable level
                setTimeout(() => {
                  if (!resolved && video.readyState >= 2) {
                    logDebug('Mobile video preloaded sufficiently (readyState: ' + video.readyState + ')');
                    markAsResolved();
                  }
                }, 3000);
              } else {
                // Desktop approach - try to preload with play/pause
                setTimeout(() => {
                  video.play().then(() => {
                    // Immediately pause after playing to preload
                    video.pause();
                    video.currentTime = 0;
                    logDebug('Video play/pause sequence completed for preloading');
                  }).catch(e => {
                    logDebug('Auto-play for preloading not allowed: ' + e.message);
                    console.warn('Auto-play for preloading not allowed:', e);
                    // This is expected on some browsers, not a critical error
                    // Check if we have enough data anyway
                    if (video.readyState >= 3) {
                      markAsResolved();
                    } else {
                      // Set a timeout to check video readiness in case events don't fire
                      setTimeout(() => {
                        if (!resolved && video.readyState >= 2) {
                          logDebug('Video preloaded via timeout check (readyState: ' + video.readyState + ')');
                          markAsResolved();
                        }
                      }, 3000);
                    }
                  });
                }, 500);
              }
              
              // Set a timeout fallback
              setTimeout(() => {
                if (!resolved) {
                  logDebug('Video preload timed out after 10 seconds, but continuing anyway');
                  
                  // Still enable the button even after timeout
                  if (launchXrBtn && launchXrBtn.disabled) {
                    launchXrBtn.disabled = false;
                    launchXrBtn.textContent = 'Launch XR Mode';
                    logDebug('XR button enabled after timeout');
                  }
                  
                  markAsResolved();
                }
              }, 10000);
            });
          };
          
          // Fallback loading method specifically for mobile devices
          function tryMobileVideoFallback(videoElement, videoSrc) {
            return new Promise((resolve, reject) => {
              logDebug('Trying mobile video fallback loading method');
              
              // Create a temporary video element
              const tempVideo = document.createElement('video');
              tempVideo.setAttribute('muted', 'true');
              tempVideo.setAttribute('playsinline', '');
              tempVideo.setAttribute('webkit-playsinline', '');
              tempVideo.setAttribute('crossorigin', 'anonymous');
              tempVideo.muted = true;
              tempVideo.style.display = 'none';
              tempVideo.crossOrigin = 'anonymous';
              document.body.appendChild(tempVideo);
              
              // Setup listeners on temp video
              tempVideo.addEventListener('canplaythrough', () => {
                logDebug('Temp video loaded successfully');
                // Transfer to main video
                videoElement.src = videoSrc;
                
                // Clean up
                document.body.removeChild(tempVideo);
                resolve();
              }, { once: true });
              
              tempVideo.addEventListener('error', (e) => {
                logDebug('Temp video also failed to load: ' + (e.message || 'unknown error'));
                // Clean up
                document.body.removeChild(tempVideo);
                reject(new Error('Mobile video fallback failed'));
              }, { once: true });
              
              // Try loading
              tempVideo.src = videoSrc;
              tempVideo.load();
              
              // Set timeout
              setTimeout(() => {
                if (tempVideo.readyState >= 2) {
                  logDebug('Temp video loaded sufficiently via timeout check');
                  // Transfer to main video
                  videoElement.src = videoSrc;
                  
                  // Clean up
                  if (document.body.contains(tempVideo)) {
                    document.body.removeChild(tempVideo);
                  }
                  resolve();
                } else {
                  logDebug('Temp video loading timed out');
                  if (document.body.contains(tempVideo)) {
                    document.body.removeChild(tempVideo);
                  }
                  reject(new Error('Mobile video fallback timed out'));
                }
              }, 5000);
            });
          }
          
          // Enter XR mode button handler
          function enterXRMode() {
            console.log('Entering XR mode...');
            
            // First check if we need to request device orientation permission (iOS 13+)
            if (isIOS && typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
              
              // Check if permission is already granted
              DeviceOrientationEvent.requestPermission()
                .then(response => {
                  if (response === 'granted') {
                    logDebug('Device orientation permission already granted');
                    activateXRMode();
                  } else {
                    logDebug('Need to request device orientation permission');
                    // Show the permission overlay
                    const permissionOverlay = document.getElementById('permission-overlay');
                    permissionOverlay.classList.add('active');
                  }
                })
                .catch(error => {
                  // If this fails, likely need user interaction first
                  logDebug('Error checking permission: ' + error);
                  
                  // Show the permission overlay
                  const permissionOverlay = document.getElementById('permission-overlay');
                  permissionOverlay.classList.add('active');
                });
              
              return; // Wait for permission response before continuing
            }
            
            // Continue with XR mode activation for non-iOS or iOS with permissions
            activateXRMode();
          }
          
          // Activate XR mode (called after permissions are checked)
          function activateXRMode() {
            logDebug('Activating XR mode...');
            document.body.style.overflow = 'hidden'; // Prevent scrolling
            
            // Show loading indicator if available
            if (loadingOverlay) {
              loadingOverlay.classList.add('active');
            }
            
            try {
              // Ensure A-Frame is properly initialized first
              if (typeof ensureAFrameSceneVisibility === 'function') {
                logDebug('Ensuring A-Frame scene visibility');
                ensureAFrameSceneVisibility();
              }
              
              // Make sure video is properly loaded
              const video = document.querySelector('#xr-video');
              if (!video) {
                throw new Error('Video element not found');
              }
              
              let videoReady = false;
              if (video.readyState >= 3) {
                videoReady = true;
                logDebug('Video is already buffered and ready');
              } else if (video.readyState < 1) {
                // If video isn't loaded at all, load it now
                logDebug('Video not loaded, loading source: ' + (video.src || initialTrack.videoSrc));
                
                if (!video.src && initialTrack && initialTrack.videoSrc) {
                  video.src = initialTrack.videoSrc;
                  video.load();
                }
              }
              
              // Get DOM elements
              const xrContainer = document.getElementById('xr-scene-container');
              const albumArt = document.querySelector('.centered-album-art');
              const exitXrBtn = document.getElementById('exit-xr');
              const launchXrBtn = document.getElementById('launch-xr');
              
              if (!xrContainer || !albumArt || !exitXrBtn || !launchXrBtn) {
                throw new Error('Required DOM elements not found');
              }
              
              // First, remove hidden class from body
              document.body.classList.remove('xr-scene-hidden');
              logDebug('Removed xr-scene-hidden class from body');
              
              // Hide album art
              albumArt.style.display = 'none';
              
              // Update button visibility
              launchXrBtn.style.display = 'none';
              exitXrBtn.style.display = 'inline-block';
              
              // Show recenter camera button in XR mode
              const recenterBtn = document.getElementById('recenter-camera-btn');
              if (recenterBtn) {
                recenterBtn.style.display = 'inline-block';
              }
              
              // Explicitly make the scene container visible with !important styles inline
              xrContainer.style.cssText = `
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                z-index: 9000 !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
              `;
              logDebug('Applied critical style overrides to XR container');
              
              // Ensure video element is properly configured for mobile
              video.setAttribute('playsinline', '');
              video.setAttribute('webkit-playsinline', '');
              video.crossOrigin = 'anonymous';
              
              // CRITICAL FIX: Setup audio/video properly for XR mode
              const audio = document.querySelector('#audio');
              if (audio) {
                // Store audio state for later
                const savedVolume = audio.volume;
                const wasMuted = audio.muted;
                
                audio.dataset.prevVolume = savedVolume;
                audio.dataset.prevMuted = wasMuted;
                
                // Mobile behavior: Keep audio playing but muted, and unmute video
                if (isMobile) {
                  audio.muted = true;
                  video.volume = savedVolume;
                  video.muted = false;
                  logDebug('Mobile: Audio muted, video unmuted with volume: ' + video.volume);
                } else {
                  // Desktop behavior: Keep audio playing and muted
                  audio.muted = true;
                  video.volume = savedVolume; 
                  video.muted = false;
                  logDebug('Desktop: Audio muted, video unmuted with volume: ' + video.volume);
                }
                
                // Sync time with audio
                video.currentTime = audio.currentTime || 0;
                logDebug('Video time synced with audio: ' + video.currentTime);
              }
              
              // Update UI for mute status
              const muteBtn = document.getElementById('mute-btn');
              const volumeIcon = document.querySelector('.volume-icon');
              const muteIcon = document.querySelector('.mute-icon');
              
              if (muteBtn) {
                if (video.muted) {
                  muteBtn.classList.add('muted');
                  if (volumeIcon) volumeIcon.style.display = 'none';
                  if (muteIcon) muteIcon.style.display = 'block';
                } else {
                  muteBtn.classList.remove('muted');
                  if (volumeIcon) volumeIcon.style.display = 'block';
                  if (muteIcon) muteIcon.style.display = 'none';
                }
              }
              
              // Try to play the video
              try {
                const playPromise = video.play();
                if (playPromise !== undefined) {
                  playPromise
                    .then(() => {
                      logDebug('Video playback started successfully');
                      
                      // Make sure to hide loading overlay
                      if (loadingOverlay) {
                        loadingOverlay.classList.remove('active');
                      }
                      
                      // Set up sync interval to keep video in sync with audio
                      const syncInterval = setInterval(() => {
                        if (Math.abs(video.currentTime - audio.currentTime) > 0.5) {
                          video.currentTime = audio.currentTime;
                          logDebug('Re-syncing video time with audio: ' + video.currentTime);
                        }
                      }, 5000);
                      
                      // Store interval for cleanup
                      window._xrSyncInterval = syncInterval;
                    })
                    .catch(error => {
                      logDebug('Error starting video playback: ' + error.message);
                      
                      // Hide loading overlay
                      if (loadingOverlay) {
                        loadingOverlay.classList.remove('active');
                      }
                      
                      // For iOS/Safari, we need user interaction
                      if (isIOS) {
                        logDebug('iOS detected, showing touch to play message');
                        alert('Please tap the screen once to enable 360° video');
                        
                        // Add one-time click handler to start playback
                        const handlePlay = () => {
                          video.play().catch(e => {
                            logDebug('Still cannot play video: ' + e.message);
                          });
                        };
                        
                        document.addEventListener('click', handlePlay, { once: true });
                      } else {
                        // For other mobile devices
                        alert('Please tap the screen to enable 360° video');
                        
                        // Add one-time click handler to start playback
                        const handlePlay = () => {
                          video.play().catch(e => {
                            logDebug('Still cannot play video: ' + e.message);
                          });
                        };
                        
                        document.addEventListener('click', handlePlay, { once: true });
                      }
                    });
                }
              } catch (e) {
                logDebug('Exception trying to play video: ' + e.message);
                
                // Hide loading overlay
                if (loadingOverlay) {
                  loadingOverlay.classList.remove('active');
                }
                
                // Fallback for older browsers - just show a message
                alert('Please tap the screen to enable 360° video');
              }
            } catch (e) {
              logDebug('Error entering XR mode: ' + e.message);
              
              // Hide loading overlay
              if (loadingOverlay) {
                loadingOverlay.classList.remove('active');
              }
              
              // Reset UI in case of error
              document.body.classList.add('xr-scene-hidden');
              
              // Show album art again
              const albumArt = document.querySelector('.centered-album-art');
              if (albumArt) {
                albumArt.style.display = 'block';
              }
              
              // Alert user
              alert('Could not enter 360° mode. Please try again.');
            }
          }
          
          // Call this function when entering XR mode to ensure A-Frame scene is visible and working
          function ensureAFrameSceneVisibility() {
            logDebug('Ensuring A-Frame scene visibility');
            
            const xrContainer = document.getElementById('xr-scene-container');
            if (!xrContainer) {
              logDebug('XR container not found');
              return false;
            }
            
            // Make sure A-Frame is loaded
            if (!window.AFRAME) {
              logDebug('A-Frame library not loaded');
              alert('A-Frame library is not loaded. Please refresh the page.');
              return false;
            }
            
            try {
              // First, remove hidden class from body
              document.body.classList.remove('xr-scene-hidden');
              logDebug('Removed xr-scene-hidden class from body');
              
              // Reset all styles to ensure visibility
              xrContainer.style.cssText = `
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                z-index: 9000 !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
              `;
              logDebug('Applied critical style overrides to XR container');
              
              // Make sure any internal A-Frame elements are visible
              const aframeElements = xrContainer.querySelectorAll('a-scene, .a-canvas');
              aframeElements.forEach(el => {
                el.style.cssText = `
                  display: block !important;
                  visibility: visible !important;
                  opacity: 1 !important;
                `;
              });
              
              // Add fallback rendering attempt if videosphere isn't rendering correctly
              const setupVideosphere = () => {
                logDebug('Setting up videosphere');
                // Get the video element
                const video = document.getElementById('xr-video');
                const scene = xrContainer.querySelector('a-scene');
                const videosphere = scene.querySelector('a-videosphere');
                
                if (video && videosphere) {
                  // Update video properties
                  video.setAttribute('playsinline', '');
                  video.setAttribute('webkit-playsinline', '');
                  video.crossOrigin = 'anonymous';
                  
                  // Reset the videosphere
                  videosphere.removeAttribute('src');
                  
                  // Force a re-render by removing and reattaching after a short delay
                  setTimeout(() => {
                    videosphere.setAttribute('src', '#xr-video');
                    logDebug('Videosphere source reattached');
                  }, 100);
                }
              };
              
              // Check if A-Frame scene exists
              const scene = xrContainer.querySelector('a-scene');
              if (!scene) {
                logDebug('A-Frame scene not found');
                return false;
              }
              
              // Make sure the scene is visible and properly styled
              scene.style.cssText = `
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                width: 100% !important;
                height: 100% !important;
                z-index: 9001 !important;
              `;
              
              // Check if A-Frame is fully initialized
              if (!scene.hasLoaded) {
                logDebug('A-Frame scene not fully loaded yet, waiting...');
                // Wait for A-Frame to fully initialize
                return new Promise((resolve) => {
                  scene.addEventListener('loaded', () => {
                    logDebug('A-Frame scene loaded event fired');
                    // Continue once loaded
                    finishSceneSetup(scene);
                    resolve(true);
                  }, { once: true });
                  
                  // Set a timeout in case the event never fires
                  setTimeout(() => {
                    logDebug('A-Frame scene load timeout, continuing anyway');
                    finishSceneSetup(scene);
                    resolve(true);
                  }, 3000);
                });
              } else {
                // A-Frame is already initialized
                return finishSceneSetup(scene);
              }
              
              function finishSceneSetup(scene) {
                // Make sure canvas is visible
                const canvas = scene.canvas;
                if (canvas) {
                  canvas.style.cssText = `
                    display: block !important;
                    width: 100% !important;
                    height: 100% !important;
                    position: absolute !important;
                    top: 0 !important;
                    left: 0 !important;
                    z-index: 9901 !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                  `;
                  logDebug('Canvas styles reset with !important flags');
                } else {
                  logDebug('A-Frame canvas not found');
                  return false;
                }
                
                // Force scene to resize if renderer exists
                if (scene.renderer) {
                  scene.renderer.setSize(window.innerWidth, window.innerHeight);
                  window.dispatchEvent(new Event('resize'));
                  logDebug('A-Frame renderer resized');
                }
                
                // Check and enable camera look controls
                const camera = scene.querySelector('[camera]');
                if (camera) {
                  // Set up camera for desktop and mobile
                  camera.setAttribute('look-controls', {
                    enabled: true,
                    touchEnabled: true,
                    magicWindowTrackingEnabled: true,
                    mouseEnabled: true,
                    reverseMouseDrag: false
                  });
                  logDebug('Camera look-controls enabled with mobile support');
                  
                  // If orientation permissions are needed for iOS, we need to handle look-controls specially
                  if (isIOS && typeof DeviceOrientationEvent !== 'undefined' && 
                      typeof DeviceOrientationEvent.requestPermission === 'function') {
                    
                    // Reset look controls after a delay to ensure they pick up permissions
                    setTimeout(() => {
                      if (camera.components && camera.components['look-controls']) {
                        camera.components['look-controls'].pause();
                        camera.components['look-controls'].play();
                        logDebug('Camera look-controls reset for iOS permission handling');
                      }
                    }, 1000);
                  }
                } else {
                  logDebug('A-Frame camera not found');
                  return false;
                }
                
                // Set up videosphere
                setupVideosphere();
                
                // Force a redraw after a short delay
                setTimeout(() => {
                  window.dispatchEvent(new Event('resize'));
                  logDebug('Forced window resize event for A-Frame');
                }, 100);
                
                return true;
              }
            } catch (e) {
              logDebug('Error showing A-Frame scene: ' + e.message);
              console.error('Error showing A-Frame scene:', e);
              return false;
            }
          }
        });
      </script>
    </div>
    
    <!-- Webflow CMS Integration Script -->
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Wait for Webflow to initialize
        if (window.Webflow && window.Webflow.push) {
          window.Webflow.push(function() {
            // Get current item data from Webflow
            const currentItem = Webflow.data.item;
            
            // Exit if no current item found
            if (!currentItem) {
              console.log('No Webflow CMS item data found, using default track');
              return;
            }
            
            console.log('Current CMS item:', currentItem);
            
            // Create track object from current item
            const currentTrack = {
              id: currentItem.id || currentItem._id,
              title: currentItem.name || 'Unknown Track',
              chapter: currentItem.chapterTitle || '',
              audioSrc: currentItem.audioSrc || currentItem.audio_src || '',
              videoSrc: currentItem.videoSrc || currentItem.XR_src || '',
              albumArt: currentItem.albumArt || '',
              trackOrder: currentItem.trackOrder || 0,
              isXR: !!currentItem.isXR // Convert to boolean value
            };
            
            // Load current track
            if (typeof PlayerCore !== 'undefined') {
              PlayerCore.loadTrack(currentTrack);
              console.log('Loaded current track:', currentTrack);
            }
            
            // Now fetch all tracks from the same collection for the playlist
            fetchAllCollectionItems(currentItem.collection_id, currentTrack.id);
          });
        }
        
        // Function to fetch all items from the same collection
        function fetchAllCollectionItems(collectionId, currentItemId) {
          // Check if we're on a Webflow site with collection APIs
          if (!collectionId || typeof Webflow === 'undefined') {
            console.error('Cannot fetch collection items - missing collection ID or Webflow API');
            return;
          }
          
          // Construct API URL for the collection
          const apiUrl = `/api/collections/${collectionId}/items?limit=100`;
          
          // Fetch all items
          fetch(apiUrl)
            .then(response => {
              if (!response.ok) throw new Error('Failed to fetch collection items');
              return response.json();
            })
            .then(data => {
              if (!data.items || !Array.isArray(data.items)) {
                throw new Error('Invalid collection items data');
              }
              
              // Transform items into playlist tracks
              const tracks = data.items.map(item => ({
                id: item.id || item._id,
                title: item.name || 'Unknown Track',
                chapter: item.chapterTitle || '',
                audioSrc: item.audioSrc || item.audio_src || '',
                videoSrc: item.videoSrc || item.XR_src || '',
                albumArt: item.albumArt || '',
                trackOrder: item.trackOrder || 0,
                isXR: !!item.isXR, // Convert to boolean value
                // Store URL to this item's page for playlist navigation
                itemUrl: item.slug ? `/${item.slug}` : null
              }));
              
              // Sort tracks by trackOrder if available
              tracks.sort((a, b) => {
                if (a.trackOrder && b.trackOrder) {
                  return a.trackOrder - b.trackOrder;
                }
                return 0; // Keep original order if no trackOrder
              });
              
              // Find index of current track
              const currentIndex = tracks.findIndex(track => track.id === currentItemId);
              
              // Create playlist object
              const playlist = {
                name: "Audio Experience",
                tracks: tracks,
                currentIndex: currentIndex >= 0 ? currentIndex : 0
              };
              
              console.log('Created playlist with', tracks.length, 'tracks');
              
              // Initialize the playlist
              if (typeof PlaylistManager !== 'undefined') {
                PlaylistManager.init(playlist);
                
                // Set custom navigation to use item URLs
                PlaylistManager.setPreviousCallback(() => {
                  const prevIndex = currentIndex - 1;
                  if (prevIndex >= 0 && tracks[prevIndex] && tracks[prevIndex].itemUrl) {
                    window.location.href = tracks[prevIndex].itemUrl;
                  }
                });
                
                PlaylistManager.setNextCallback(() => {
                  const nextIndex = currentIndex + 1;
                  if (nextIndex < tracks.length && tracks[nextIndex] && tracks[nextIndex].itemUrl) {
                    window.location.href = tracks[nextIndex].itemUrl;
                  }
                });
                
                // Populate playlist UI
                populatePlaylistUI(tracks, currentItemId);
              }
            })
            .catch(error => {
              console.error('Error fetching collection items:', error);
            });
        }
        
        // Function to populate the playlist UI
        function populatePlaylistUI(tracks, currentItemId) {
          const playlistContainer = document.getElementById('playlist-tracks');
          if (!playlistContainer) return;
          
          // Clear existing items
          playlistContainer.innerHTML = '';
          
          // Add tracks to playlist UI
          tracks.forEach((track, index) => {
            const li = document.createElement('li');
            if (track.id === currentItemId) {
              li.classList.add('active');
            }
            
            li.innerHTML = `
              <div class="track-title">${track.trackOrder ? `${track.trackOrder}. ` : ''}${track.title}</div>
              <div class="track-chapter">${track.chapter}</div>
            `;
            
            // Add click handler to navigate to track
            li.addEventListener('click', () => {
              // Exit XR mode before navigating to new track
              if (typeof XRController !== 'undefined' && XRController.isInXRMode()) {
                console.log('Exiting XR mode before navigating to selected track');
                XRController.exitXRMode();
              }
              
              if (track.itemUrl) {
                window.location.href = track.itemUrl;
              }
            });
            
            playlistContainer.appendChild(li);
          });
        }
      });
    </script>

    <!-- Add helper function for recenter camera -->
    <script>
      // Add recenter camera functionality that will be available globally
      function addRecenterCameraHandler() {
        const recenterBtn = document.getElementById('recenter-camera-btn');
        if (!recenterBtn) return;
        
        // Clear any existing event listeners
        const newButton = recenterBtn.cloneNode(true);
        recenterBtn.parentNode.replaceChild(newButton, recenterBtn);
        
        // Add event listener to the new button
        newButton.addEventListener('click', function() {
          console.log('Recenter camera button clicked');
          
          // First try to use the global recenterCamera function if available
          if (typeof recenterCamera === 'function') {
            recenterCamera();
            // Flash feedback to user
            this.classList.add('active');
            setTimeout(() => {
              this.classList.remove('active');
            }, 300);
            return;
          }
          
          // Fallback to direct camera manipulation if global function not available
          const scene = document.querySelector('a-scene');
          if (!scene) {
            console.log('Scene not found for recenter');
            return;
          }
          
          const camera = scene.querySelector('[camera]');
          if (!camera) {
            console.log('Camera not found for recenter');
            return;
          }
          
          // Reset camera rotation
          camera.setAttribute('rotation', '0 0 0');
          
          // Flash feedback to user
          this.classList.add('active');
          setTimeout(() => {
            this.classList.remove('active');
          }, 300);
          
          // If using look-controls, also reset their state
          if (camera.components && camera.components['look-controls']) {
            const lookControls = camera.components['look-controls'];
            if (lookControls) {
              try {
                // Reset rotation objects manually
                if (lookControls.pitchObject) lookControls.pitchObject.rotation.x = 0;
                if (lookControls.yawObject) lookControls.yawObject.rotation.y = 0;
                console.log('Camera look controls reset');
              } catch (e) {
                console.error('Error resetting camera look controls:', e);
              }
            }
          }
          
          console.log('Camera reset completed');
        });
        
        console.log('Recenter camera handler added');
      }
      
      // Ensure A-Frame scene is properly initialized
      function initializeAFrameScene() {
        console.log('Initializing A-Frame scene');
        const xrContainer = document.getElementById('xr-scene-container');
        if (!xrContainer) return false;
        
        const scene = xrContainer.querySelector('a-scene');
        if (!scene) return false;
        
        // Force scene to be hidden but initialized
        document.body.classList.add('xr-scene-hidden');
        
        // Handle scene loaded event
        const isLoaded = scene.hasLoaded;
        if (!isLoaded) {
          scene.addEventListener('loaded', function() {
            console.log('A-Frame scene loaded event fired');
            finishSceneSetup(scene);
          });
        } else {
          finishSceneSetup(scene);
        }
        
        function finishSceneSetup(scene) {
          // Initialize video element
          const video = document.getElementById('xr-video');
          if (video) {
            video.setAttribute('crossorigin', 'anonymous');
            video.crossOrigin = 'anonymous';
          }
          
          // Ensure camera has look-controls
          const camera = scene.querySelector('[camera]');
          if (camera) {
            camera.setAttribute('look-controls', 'enabled: true; reverseMouseDrag: false');
          }
          
          // Add camera reset handler
          addRecenterCameraHandler();
          
          console.log('A-Frame scene initialization complete');
          return true;
        }
        
        return true;
      }
      
      // Call this function after DOM is loaded and again when entering XR mode
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize A-Frame scene first
        setTimeout(initializeAFrameScene, 300);
        
        // Then add recenter handler
        setTimeout(addRecenterCameraHandler, 800);
      });
    </script>

    <!-- Failsafe mechanism to ensure critical functions are available -->
    <script>
      // Add a window load event that checks and reinstates any missing functionality
      window.addEventListener('load', function() {
        // Check XR button state
        const launchXrBtn = document.getElementById('launch-xr');
        const video = document.getElementById('xr-video');
        
        if (launchXrBtn && video) {
          // Ensure button state is correct based on video readiness
          if (video.readyState >= 3) {
            launchXrBtn.disabled = false;
            launchXrBtn.textContent = 'Launch XR Mode';
            console.log('XR button enabled by window load handler');
          }
          
          // Add a click listener to the document to handle user interaction
          // requirements for video loading in some browsers
          document.addEventListener('click', function() {
            // After user interaction, try to preload video again if needed
            if (launchXrBtn.disabled && video.readyState < 3) {
              console.log('User interaction detected, trying to load video');
              video.load();
              setTimeout(() => {
                if (video.readyState >= 3) {
                  launchXrBtn.disabled = false;
                  launchXrBtn.textContent = 'Launch XR Mode';
                  console.log('XR button enabled after user interaction');
                }
              }, 1000);
            }
          }, { once: true });
          
          // Safety timeout to ensure button becomes enabled eventually
          setTimeout(() => {
            if (launchXrBtn.disabled) {
              launchXrBtn.disabled = false;
              launchXrBtn.textContent = 'Launch XR Mode';
              console.log('XR button enabled by failsafe timeout');
            }
          }, 20000);
        }
        
        // Check if recenterCamera function exists, if not, create it
        if (typeof recenterCamera !== 'function') {
          console.log('Adding failsafe recenterCamera function');
          
          window.recenterCamera = function() {
            console.log('Failsafe recenter camera function called');
            
            try {
              // Get the A-Frame scene and camera
              const scene = document.querySelector('a-scene');
              if (!scene) return false;
              
              const camera = scene.querySelector('[camera]');
              if (!camera) return false;
              
              // Reset camera rotation
              camera.setAttribute('rotation', '0 0 0');
              
              // Try to reset look-controls
              if (camera.components && camera.components['look-controls']) {
                const lookControls = camera.components['look-controls'];
                if (lookControls) {
                  if (lookControls.pitchObject) lookControls.pitchObject.rotation.x = 0;
                  if (lookControls.yawObject) lookControls.yawObject.rotation.y = 0;
                }
              }
              
              return true;
            } catch (e) {
              console.error('Error in failsafe recenterCamera:', e);
              return false;
            }
          };
        }
        
        // Check if the recenter button has event listeners, if not add them
        const recenterBtn = document.getElementById('recenter-camera-btn');
        if (recenterBtn) {
          // Force add event listener that uses our global function
          recenterBtn.addEventListener('click', function() {
            console.log('Failsafe recenter button clicked');
            
            // Use the global recenterCamera function
            if (typeof recenterCamera === 'function') {
              recenterCamera();
            }
            
            // Visual feedback
            this.classList.add('active');
            setTimeout(() => {
              this.classList.remove('active');
            }, 300);
          });
        }
        
        // Mobile device specific optimizations
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        
        if (isMobile) {
          console.log('Mobile device detected, applying optimizations');
          
          // Make sure video has proper attributes for mobile
          const videoElement = document.getElementById('xr-video');
          if (videoElement) {
            videoElement.setAttribute('playsinline', '');
            videoElement.setAttribute('webkit-playsinline', '');
            videoElement.setAttribute('crossorigin', 'anonymous');
            videoElement.crossOrigin = 'anonymous';
            console.log('Mobile video attributes set');
          }
          
          // Handle iOS device orientation permission
          if (isIOS && typeof DeviceOrientationEvent !== 'undefined' && 
              typeof DeviceOrientationEvent.requestPermission === 'function') {
            
            console.log('iOS device orientation permissions may be needed');
            
            // Add a global click handler to request permission on first user interaction
            document.addEventListener('click', function() {
              DeviceOrientationEvent.requestPermission()
                .then(response => {
                  console.log('Device orientation permission response:', response);
                  if (response === 'granted') {
                    // Refresh A-Frame camera to pick up permissions
                    const camera = document.querySelector('a-entity[camera]');
                    if (camera && camera.components && camera.components['look-controls']) {
                      camera.components['look-controls'].pause();
                      camera.components['look-controls'].play();
                      console.log('Camera look-controls reset after iOS permission granted');
                    }
                  }
                })
                .catch(error => {
                  console.warn('Could not request device orientation permission yet:', error);
                });
            }, { once: true });
          }
        }
      });
    </script>
  </body>
</html>